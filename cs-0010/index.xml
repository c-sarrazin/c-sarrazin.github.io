<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>25</fr:day>
    </fr:date>
    <fr:uri>https://c-sarrazin.github.io/cs-0010/</fr:uri>
    <fr:display-uri>cs-0010</fr:display-uri>
    <fr:route>/cs-0010/</fr:route>
    <fr:title text="Crochet de Poisson">Crochet de Poisson</fr:title>
    <fr:taxon>Définition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Soient <fr:tex display="inline"><![CDATA[f, g]]></fr:tex> deux fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On note <fr:tex display="block"><![CDATA[\{f,g\} = \omega (X_f, X_g) \in  \mathscr {C}^\infty (T^*M).]]></fr:tex></html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://c-sarrazin.github.io/cs-000J/</fr:uri>
            <fr:display-uri>cs-000J</fr:display-uri>
            <fr:route>/cs-000J/</fr:route>
            <fr:title text="Mécanique hamiltonienne">Mécanique hamiltonienne</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>18</fr:day>
                </fr:date>
                <fr:title text="Équations de Newton et d'Hamilton">Équations de Newton et d'Hamilton</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>On considère un point matériel de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> évoluant sur une variété riemannienne <fr:tex display="inline"><![CDATA[M]]></fr:tex> et soumis à une force. Pour décrire sa dynamique, on peut écrire une équation de Newton "coordinate-free" :</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000S/</fr:uri><fr:display-uri>cs-000S</fr:display-uri><fr:route>/cs-000S/</fr:route><fr:title text="Équation de Newton">Équation de Newton</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel, i.e. une fonction lisse <fr:tex display="inline"><![CDATA[V : M \to  \mathbb {R}]]></fr:tex>. L'équation de Newton sur <fr:tex display="inline"><![CDATA[M]]></fr:tex> s'écrit : <fr:tex display="block"><![CDATA[m\nabla _{\dot {x}}\dot {x} = -\mathrm {grad}_g \, V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarques</fr:taxon></fr:frontmatter><fr:mainmatter><html:ol><html:li>Quand <fr:tex display="inline"><![CDATA[M = \mathbb {R^n}]]></fr:tex> muni de la métrique canonique, on obtient ainsi l'équation de Newton bien connue <fr:tex display="block"><![CDATA[m\ddot {x} = -\mathrm {grad} \, V = F.]]></fr:tex></html:li>
      <html:li>Quand notre point matériel n'est soumis à aucune force (potentiel nul) on obtient l'équation pour des géodésiques sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>, qui remplacent la ligne droite dans le mouvement rectiligne uniforme.</html:li>
      <html:li>On traite ici uniquement des forces conservatives, mais on pourrait remplacer <fr:tex display="inline"><![CDATA[-\mathrm {grad}_g\, V]]></fr:tex> par un champ de vecteurs quelconque (le champ de force).</html:li></html:ol></fr:mainmatter></fr:tree>
<html:p>On obtient ainsi une équation d'ordre 2 sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>. On veut se ramener à une équation d'ordre 1 sur l'espace des phases <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>, où l'état d'un point est décrit par sa position est son moment.</html:p>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Le vecteur vitesse est un élément de <fr:tex display="inline"><![CDATA[TM]]></fr:tex>. Le moment, lui, est un élément de <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Comme <fr:tex display="inline"><![CDATA[M]]></fr:tex> est une variété riemannienne, on dispose pour passer de l'un à l'autre des isomorphismes dits musicaux <fr:tex display="block"><![CDATA[\begin {align*}\sharp  : T^*M &\to  TM \\ p &\mapsto  p^{\sharp }\end {align*} \qquad  \begin {align*}\flat  : TM &\to  T^*M \\ v &\mapsto  v^{\flat }\end {align*}]]></fr:tex>qui ne sont autres que sur chaque fibre l'isomorphisme entre un espace vectoriel et son dual qui est donné par un produit scalaire.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000U/</fr:uri><fr:display-uri>cs-000U</fr:display-uri><fr:route>/cs-000U/</fr:route><fr:title text="Hamiltonien">Hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel <fr:tex display="inline"><![CDATA[V]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[(x,p) \in  T^*M]]></fr:tex>. On note le hamiltonien associé à <fr:tex display="inline"><![CDATA[V]]></fr:tex> <fr:tex display="block"><![CDATA[H(x,p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree><html:p>Ce hamiltonien décrit l'énergie totale (mécanique) du système : énergie cinétique + énergie potentielle. On peut réécrire l'équation de Newton comme une équation de degré 1 sur l'espace des phases qui ne fait intervenir que <fr:tex display="inline"><![CDATA[H]]></fr:tex>, c'est à dire associer à <fr:tex display="inline"><![CDATA[H]]></fr:tex> un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> dont le flot sera l'évolution du système. On dispose déjà de la différentielle <fr:tex display="inline"><![CDATA[\mathrm {d}H \in  T^*T^*M]]></fr:tex> ; il nous reste à identifier canoniquement <fr:tex display="inline"><![CDATA[TT^*M]]></fr:tex> et <fr:tex display="inline"><![CDATA[T^*T^*M]]></fr:tex>. Cela est rendu possible par la forme symplectique.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000V/</fr:uri><fr:display-uri>cs-000V</fr:display-uri><fr:route>/cs-000V/</fr:route><fr:title text="Forme symplectique sur T^*M">Forme symplectique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex> la 1-forme tautologique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> : 
<fr:tex display="block"><![CDATA[\begin {align*}
\lambda  : T^*M &\to  T^*T^*M \\
(x, p) &\mapsto  p \circ  \mathrm {d}_x \pi  
\end {align*}]]></fr:tex>
On pose <fr:tex display="inline"><![CDATA[\omega  = - \mathrm {d}\lambda ]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Si <fr:tex display="inline"><![CDATA[M=\mathbb {R}^n]]></fr:tex>, on a <fr:tex display="inline"><![CDATA[T^*M = \mathbb {R}^{2n}]]></fr:tex> et la forme symplectique s'écrit <fr:tex display="block"><![CDATA[\omega  = \sum _{i=1}^n \mathrm {d}x_i \wedge  \mathrm {d}p_i]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p>Il s'agit d'une 2-forme non dégénérée : si <fr:tex display="inline"><![CDATA[X]]></fr:tex> est un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[\omega (X, Y) = 0]]></fr:tex> pour tout autre champ de vecteurs <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, alors <fr:tex display="inline"><![CDATA[X]]></fr:tex> est nul. Cette non dégénérescence garantit la bonne définition de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> comme suit.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000W/</fr:uri><fr:display-uri>cs-000W</fr:display-uri><fr:route>/cs-000W/</fr:route><fr:title text="Champ hamiltonien">Champ hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : T^*M \to  \mathbb {R}]]></fr:tex> un hamiltonien. On note <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> l'unique champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="block"><![CDATA[\omega (X_H, \cdot ) = \mathrm {d}H(\cdot ).]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000T/</fr:uri><fr:display-uri>cs-000T</fr:display-uri><fr:route>/cs-000T/</fr:route><fr:title text="Équation d'Hamilton">Équation d'Hamilton</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\gamma (t)]]></fr:tex> est une solution à l'<fr:link href="/cs-000S/" title="Équation de Newton" uri="https://c-sarrazin.github.io/cs-000S/" display-uri="cs-000S" type="local">équation de Newton</fr:link> si et seulement si <fr:tex display="inline"><![CDATA[(\gamma (t), m\dot {\gamma }(t)^\flat )]]></fr:tex> est une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>T'as cru</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : \mathbb {R}^{2n} \to  \mathbb {R}]]></fr:tex> une fonction lisse. Le champ hamiltonien associé s'écrit <fr:tex display="block"><![CDATA[X_H = \left (\frac {\partial  H}{\partial  p_i}, -\frac {\partial  H}{\partial  x_i}\right )]]></fr:tex>et donc l'équation du mouvement devient <fr:tex display="block"><![CDATA[\dot {x}_i = \frac {\partial  H}{\partial  p_i} \qquad  \dot {p}_i = -\frac {\partial  H}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>18</fr:day>
                </fr:date>
                <fr:title text="Conséquences de l'équation d'Hamilton">Conséquences de l'équation d'Hamilton</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>La forme symplectique <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> donne naturellement une notion de volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000X/</fr:uri><fr:display-uri>cs-000X</fr:display-uri><fr:route>/cs-000X/</fr:route><fr:title text="Forme volume sur T^*M">Forme volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme symplectique donne sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> la forme volume <fr:tex display="inline"><![CDATA[\frac {\omega ^{\wedge  n}}{n!}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme volume ainsi obtenue est juste la forme volume standard <fr:tex display="block"><![CDATA[\mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n \wedge  \mathrm {d} p_1 \wedge  \cdots  \wedge  \mathrm {d} p_n.]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0014/</fr:uri><fr:display-uri>cs-0014</fr:display-uri><fr:route>/cs-0014/</fr:route><fr:title text="Mesure associée à une forme volume">Mesure associée à une forme volume</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[M^n]]></fr:tex> une variété lisse munie d'une <fr:tex display="inline"><![CDATA[n]]></fr:tex>-forme ne s'annulant jamais. Elle est donc orientée. Localement dans une carte orientée positivement <fr:tex display="inline"><![CDATA[(U, \phi )]]></fr:tex>, notre forme volume est de la forme <fr:tex display="block"><![CDATA[f \, \mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n]]></fr:tex>avec <fr:tex display="inline"><![CDATA[f>0]]></fr:tex>. On pose alors pour un borélien <fr:tex display="inline"><![CDATA[B]]></fr:tex> contenu dans cette carte <fr:tex display="block"><![CDATA[\mathscr {A}(B) = \int _{\phi (B)} f.]]></fr:tex>La formule de changement de variable implique que si <fr:tex display="inline"><![CDATA[B]]></fr:tex> se trouve dans l'intersection de deux cartes, l'aire de <fr:tex display="inline"><![CDATA[B]]></fr:tex> ne dépend pas de la carte choisie pour la calculer. On définit alors l'aire d'un borélien quelconque via une partition de l'unité. On obtient ainsi une mesure de Radon sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier, ce procédé appliqué à la forme volume standard sur <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex> redonne la mesure de Lebesgue (sur les boréliens).</html:p></fr:mainmatter></fr:tree>
<html:p>La forme symplectique est naturellement conservée le long d'un flot hamiltonien.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Y/</fr:uri><fr:display-uri>cs-000Y</fr:display-uri><fr:route>/cs-000Y/</fr:route><fr:title text="Un difféomorphisme hamiltonien est un symplectomorphisme">Un difféomorphisme hamiltonien est un symplectomorphisme</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H]]></fr:tex> une fonction lisse sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[\phi ^t_H]]></fr:tex> le flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Alors <fr:tex display="block"><![CDATA[(\phi ^t_H)^* \omega  = \omega .]]></fr:tex></html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Trolololol</html:p></fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><html:p>Cela donne une première conséquence, presque triviale dans notre cadre symplectique, connue sous le nom de théorème de Liouville.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Z/</fr:uri><fr:display-uri>cs-000Z</fr:display-uri><fr:route>/cs-000Z/</fr:route><fr:title text="Théorème de Liouville">Théorème de Liouville</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La mesure ainsi définie sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> est préservé par un flot hamiltonien, c'est à dire par l'évolution en temps du système mécanique.</html:p></fr:mainmatter></fr:tree><html:p>Une deuxième conséquence est qu'il est facile - du moins en théorie - d'obtenir des équations d'évolution pour des observables quelconques.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0010/</fr:uri><fr:display-uri>cs-0010</fr:display-uri><fr:route>/cs-0010/</fr:route><fr:title text="Crochet de Poisson">Crochet de Poisson</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g]]></fr:tex> deux fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On note <fr:tex display="block"><![CDATA[\{f,g\} = \omega (X_f, X_g) \in  \mathscr {C}^\infty (T^*M).]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Sur <fr:tex display="inline"><![CDATA[\mathbb {R}^{2n}]]></fr:tex>, on a <fr:tex display="block"><![CDATA[\{ f,g \} = 
    \sum _{i}^n \frac {\partial  f}{\partial  x_i} \frac {\partial  g}{\partial  p_i} - \frac {\partial  f}{\partial  p_i} \frac {\partial  g}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0012/</fr:uri><fr:display-uri>cs-0012</fr:display-uri><fr:route>/cs-0012/</fr:route><fr:title text="L'algèbre de Lie \mathscr {C}^\infty (T^*M)">L'algèbre de Lie <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex></fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f,g,h]]></fr:tex> trois fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On a :</html:p><html:ol><html:li>(linéarité)  <fr:tex display="inline"><![CDATA[\{f, g + \lambda  h\} = \{f,g\} + \lambda \{f,h\} ;]]></fr:tex></html:li>
  <html:li>(antisymétrie) <fr:tex display="inline"><![CDATA[\{f,g\}= -\{g,f\} ;]]></fr:tex></html:li>
  <html:li>(identité de Jacobi) <fr:tex display="inline"><![CDATA[ \{f, \{g,h\} \} + \{g, \{h,f\} \} + \{h, \{f,g\} \} = 0;]]></fr:tex></html:li>
  <html:li>(identité de Leibniz) <fr:tex display="inline"><![CDATA[ \{f, gh\} = \{f,g\}h + \{f,h\}g;]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\partial _t \{f,g\} = \{\partial _t f, g\} + \{f, \partial _t g\}.]]></fr:tex></html:li></html:ol><html:p>En particulier, le crochet de Poisson fait de l'algèbre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> une algèbre de Lie.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Simples vérifications.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0015/</fr:uri><fr:display-uri>cs-0015</fr:display-uri><fr:route>/cs-0015/</fr:route><fr:title text="Morphisme d'algèbres de Lie">Morphisme d'algèbres de Lie</fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g\in  \mathscr {C}^\infty (T^*M)]]></fr:tex>. Alors on a <fr:tex display="block"><![CDATA[X_{ \{f, g\} } = [X_f, X_g],]]></fr:tex>
autrement dit <fr:tex display="inline"><![CDATA[f \mapsto  X_f]]></fr:tex> est un morphisme d'algèbres de Lie entre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> et <fr:tex display="inline"><![CDATA[\mathfrak {X}(T^*M)]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Oui oui...</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0011/</fr:uri><fr:display-uri>cs-0011</fr:display-uri><fr:route>/cs-0011/</fr:route><fr:title text="Équation d'évolution pour un observable quelconque">Équation d'évolution pour un observable quelconque</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\gamma ]]></fr:tex> une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[f\in  \mathscr {C}^\infty (M)]]></fr:tex>. On a l'équation suivante : <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (f \circ  \gamma ) = \{f, H\}.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0013/</fr:uri><fr:display-uri>cs-0013</fr:display-uri><fr:route>/cs-0013/</fr:route><fr:title text="Conservation de l'énergie">Conservation de l'énergie</fr:title><fr:taxon>Corollaire</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier,  <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (H \circ  \gamma ) = \{H, H\} = 0]]></fr:tex>c'est à dire que <fr:tex display="inline"><![CDATA[H]]></fr:tex> est constante le long du flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Autrement dit, il y a conservation de l'énergie mécanique.</html:p></fr:mainmatter></fr:tree></fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>18</fr:day>
                </fr:date>
                <fr:title text="Quelques exemples physiques">Quelques exemples physiques</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>26</fr:day>
                    </fr:date>
                    <fr:uri>https://c-sarrazin.github.io/cs-0016/</fr:uri>
                    <fr:display-uri>cs-0016</fr:display-uri>
                    <fr:route>/cs-0016/</fr:route>
                    <fr:title text="L'exemple du pendule sphérique">L'exemple du pendule sphérique</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Un pendule sphérique est constitué d'un point de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> fixé à une tige de longueur 1. La position de la masse est décrite par un point <fr:tex display="inline"><![CDATA[x = (x_1, x_2, x_3) \in  S^2]]></fr:tex> la sphère unité. Sa vitesse est décrite par <fr:tex display="inline"><![CDATA[v \in  T_xS^2]]></fr:tex>, c'est à dire <fr:tex display="inline"><![CDATA[(v_1, v_2, v_3) \in  \mathbb {R}^3]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[v\cdot  x = 0]]></fr:tex>.</html:p>
                    <html:p>En tant que sous-variété de <fr:tex display="inline"><![CDATA[\mathbb {R}^3]]></fr:tex>, <fr:tex display="inline"><![CDATA[S^2]]></fr:tex> est munie d'une métrique riemannienne induite. On peut donc dire que le moment de la masse est décrit par <fr:tex display="inline"><![CDATA[p = mv^\flat  \in  T^*S^2]]></fr:tex>.</html:p>
                    <html:p>La seule force à laquelle est soumise la masse est la gravité. Cela donne le hamiltonien <fr:tex display="block"><![CDATA[H(x, p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + mg x_3 = \frac {1}{2m}\left (p_{\theta }^2 + \frac {p_\phi ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>en réécrivant le hamiltonien en coordonnées sphériques sur <fr:tex display="inline"><![CDATA[S^2 \setminus  \{S, N\} \cong  ] 0, \pi   [ \times  ] 0, 2\pi   []]></fr:tex>.</html:p>
                    <html:p>Les équations de Hamilton sont donc <fr:tex display="block"><![CDATA[\begin {align*}
    \dot \theta  = \frac {p_\theta }{m} \qquad  \dot \phi  = \frac {p_\phi }{m\sin ^2 \theta } \\
    \dot {p}_\theta  = \frac {p_\phi  ^2 \cos  \theta }{m\sin ^3 \theta } + mg \sin  \theta  \qquad  \dot {p}_\phi  = 0
    \end {align*}]]></fr:tex></html:p>
                    <html:p>De ces équations, un physicien peut tirer des équations du second ordre en <fr:tex display="inline"><![CDATA[\theta ]]></fr:tex> et <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. On remarque aussi qu'une quantité est conservée : <fr:tex display="block"><![CDATA[p_\phi  = m \sin ^2 \theta  \dot {\phi } = (x \times  mv)_3.]]></fr:tex>
    Il s'agit du moment angulaire autour de l'axe vertical. Il est conservé car le système est invariant par rotation autour de l'axe vertical. C'est une illustration du principe de Noether : à une symétrie correspond une quantité conservée. Appelons-la :<fr:tex display="block"><![CDATA[\begin {align*}J : T^*S^2 &\to  \mathbb {R} \\
    (x,p) &\mapsto  (x \times  mv)_3\end {align*}]]></fr:tex>
    <fr:tex display="inline"><![CDATA[J]]></fr:tex> a une valeur singulière en <fr:tex display="inline"><![CDATA[\mu  = 0]]></fr:tex> venant des singularités aux pôles. Pour <fr:tex display="inline"><![CDATA[\mu  \neq  0]]></fr:tex>, <fr:tex display="inline"><![CDATA[J^{-1}(\mu )]]></fr:tex> est une sous-variété de codimension 1 de <fr:tex display="inline"><![CDATA[T^*S^2]]></fr:tex> qui est invariante par le flot. En coordonnées sphériques, il s'agit simplement de <fr:tex display="inline"><![CDATA[ \{(\theta , \phi , p_\theta , p_\phi  = \mu )\} \cong  ] 0, \pi   [ \times  S^1 \times  \mathbb {R}]]></fr:tex>
    Sur cette sous-variété, la symétrie circulaire donne une action propre et libre de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex>, par translation sur la deuxième coordonnée. On considère l'espace de phase réduit <fr:tex display="block"><![CDATA[M_\mu  := J^{-1}(\mu )/S^1 \cong  ] 0, \pi   [ \times  \mathbb {R}]]></fr:tex>
    qui est encore une variété lisse, de dimension 2 cette fois. C'est l'espace des phases où on a identifié deux états qui ne diffèrent que d'une rotation axiale. Résumons la situation :
    
 
  
  <html:figure><fr:resource hash="08e4848a9957b216e9ca2170ca000550"><fr:resource-content><html:img src="/08e4848a9957b216e9ca2170ca000550.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
\begin {tikzcd}
J^{-1}(\mu ) \arrow [r, "\iota ", hook] \arrow [d, "\pi ", two heads] & T^*S^2 \\
J^{-1}(\mu )/S^1                                                  &       
\end {tikzcd}
    ]]></fr:resource-source></fr:resource></html:figure>
 

    On cherche à obtenir une forme symplectique induite sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex>, c'est à dire une 2-forme <fr:tex display="inline"><![CDATA[\omega _{\text {red}}]]></fr:tex> fermée non dégénérée telle que <fr:tex display="inline"><![CDATA[\pi ^*\omega _{\text {red}} = \iota ^*\omega ]]></fr:tex>. Ici, on voit que <fr:tex display="inline"><![CDATA[\mathrm {d}\theta  \wedge  \mathrm {d} p_\theta ]]></fr:tex> convient.
</html:p>
                    <html:p>Cela suffit pour définir le crochet de Poisson et les champs hamiltoniens comme auparavant! Ici, comme le hamiltonien est invariant sous l'action de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex> (en clair, ne dépend pas de <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>), il induit sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex> le hamiltonien <fr:tex display="block"><![CDATA[H_\mu (\theta , p_\theta ) = \frac {1}{2m}\left (p_{\theta }^2 + \frac {\mu ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>
et les équations d'Hamilton associées à <fr:tex display="inline"><![CDATA[H_\mu ]]></fr:tex> décrivent la dynamique sur l'espace de phases réduit. (Dans ce cas très spécial, on retrouve simplement les équations déjà connues.)</html:p>
                    <html:p>On a ainsi exploité la symétrie pour se ramener d'un système en deux (quatre) dimensions à un système à une (deux) dimensions. C'est la réduction symplectique, qu'on rencontrera en toute généralité plus tard. De plus, la réduction symplectique d'un espace de phases complet <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> peut donner une variété qui n'est plus naturellement un espace cotangent, mais qui est quand même muni d'une 2-forme fermée non dégénérée induite par la forme symplectique canonique : c'est une variété symplectique !</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

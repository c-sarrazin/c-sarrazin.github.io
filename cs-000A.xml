<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>864</anchor>   <addr>cs-000A</addr>  <route>cs-000A.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Calcul différentiel</title>  </frontmatter> <mainmatter/> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>865</anchor>   <addr>index</addr>  <route>index.xml</route>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Sofia</title>  </frontmatter> <mainmatter><p class="startpage" style="display: none">hihi</p><p>Sofia est une &quot;forêt&quot; crée avec <link href="http://www.jonmsterling.com/jms-005P.xml" type="external">Forester</link>. Elle rassemble mes notes de maths et mon <link href="journal.xml" type="local" addr="journal" title="Journal mathématique">journal mathématique</link> depuis janvier 2024. La plupart de ces notes sont transférées depuis Mimi, coffre <link href="https://obsidian.md" type="external">Obsidian</link> ayant vécu de 2021 à 2024. Repose en paix, Mimi.</p><p>Quelques points de départ de mes notes :</p>


<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>866</anchor>   <addr>cs-0004</addr>  <route>cs-0004.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégories, foncteurs, jolis diagrammes</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>867</anchor>  <taxon>Définition</taxon> <addr>cs-0002</addr>  <route>cs-0002.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégorie</title>  </frontmatter> <mainmatter><p> Une <em>catégorie</em> <tex>\mathscr {C}</tex> est la donnée de :</p><ol><li>une collection d'objets <tex>\mathrm {Ob}( \mathscr {C})</tex>,</li>
  <li>pour toute paire d'objets <tex>x, y  \in   \mathrm {Ob}( \mathscr {C})</tex>, une collection de morphismes <tex>\mathrm {Hom}_{ \mathscr {C}}(x,y)</tex>,</li></ol><p>telle que :</p><ol><li>pour tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex>, on ait un morphisme <tex>\mathrm {Id}_x  \in   \mathrm {Hom}_{ \mathscr {C}}(x,x)</tex>,</li>
  <li>pour tous morphismes <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, on ait un morphisme <tex>g  \circ  f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,z)</tex></li></ol><p>tels que le diagramme suivant commute :</p>
 <embedded-tex hash="3ff8e05116b4e159509dfb442821e0a3"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
 \begin {tikzcd}
w  \arrow [r, &quot;f&quot;]  \arrow [rr, &quot;g  \circ  f&quot;, bend left=49]  \arrow [&quot; \mathrm {Id}_w&quot;', loop, distance=2em, in=305, out=235] &amp; x  \arrow [r, &quot;g&quot;]  \arrow [rr, &quot;h  \circ  g&quot;, bend right=49] &amp; y  \arrow [r, &quot;h&quot;] &amp; z  \arrow [&quot; \mathrm {Id}_z&quot;', loop, distance=2em, in=125, out=55]
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<p>Autrement dit, la composition est associative, et composer par un morphisme identité n'a aucun effet.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>868</anchor>  <taxon>Exemples</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title/>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>869</anchor>  <taxon>Définition</taxon> <addr>cs-000L</addr>  <route>cs-000L.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Foncteur</title>  </frontmatter> <mainmatter><p>Soient <tex>\mathscr {C}</tex> et <tex>\mathscr {D}</tex> deux <link href="cs-0002.xml" type="local" addr="cs-0002" title="Catégorie">catégories</link>. Un <em>foncteur</em> (covariant) <tex>\mathcal {F}</tex> de <tex>\mathscr {C}</tex> vers <tex>\mathscr {D}</tex> associe :</p><ul><li>à tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex> un objet <tex>\mathcal {F}(x)  \in   \mathrm {Ob}( \mathscr {D})</tex>,</li>
  <li>à tout morphisme <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x, y)</tex> un morphisme <tex>\mathcal {F}(f)  \in   \mathrm {Hom}_{ \mathscr {D}}( \mathcal {F}(x),  \mathcal {F}(y))</tex>,</li></ul><p>tel que :</p><ul><li><tex>\mathcal {F}( \mathrm {Id}_x) =  \mathrm {Id}_{ \mathcal {F}(x)}</tex>,</li>
  <li>pour <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, <tex>\mathcal {F}(g  \circ  f) =  \mathcal {F}(g)  \circ   \mathcal {F}(f)</tex>.</li></ul></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>870</anchor>   <addr>cs-0008</addr>  <route>cs-0008.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre linéaire</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>871</anchor>   <addr>cs-0007</addr>  <route>cs-0007.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie</title>  </frontmatter> <mainmatter><p>La topologie est l'étude des espaces les plus généraux possibles où étudier les notions de <link href="todo.xml" type="local" addr="todo" title="À faire">continuité</link> et de <link href="todo.xml" type="local" addr="todo" title="À faire">convergence</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>872</anchor>   <addr>cs-000H</addr>  <route>cs-000H.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Topologie de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>873</anchor>  <taxon>Définition</taxon> <addr>cs-000G</addr>  <route>cs-000G.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Convergence d'une suite réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>(u_n)</tex> une suite réelle. On dit qu'elle converge vers <tex>\ell</tex> quand <tex display="block">\forall   \varepsilon  &gt; 0,  \exists  N  \in   \mathbb {N}, n &gt; N  \implies   \lvert  u_n -  \ell   \rvert  &lt;  \varepsilon</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>874</anchor>  <taxon>Définition</taxon> <addr>cs-000I</addr>  <route>cs-000I.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Continuité d'une fonction réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>f : I  \to   \mathbb {R}</tex> une fonction réelle. On dit qu'elle est continue en <tex>a  \in   \mathbb {R}</tex> quand <tex display="block">\lim _{x \to  a} f(x) = f(a)</tex></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>875</anchor>  <taxon>Propriété</taxon> <addr>cs-000J</addr>  <route>cs-000J.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Caractérisations de la continuité</title>  </frontmatter> <mainmatter><p>Les conditions suivantes sont équivalentes :</p><ol><li><tex>f</tex> est continue en <tex>a</tex> ;</li>
  <li>Pour toute suite réelle <tex>(x_n)</tex> convergeant vers <tex>a</tex>, <tex>f(x_n)  \to  f(a)</tex> ;</li>
  <li>Pour tout <tex>\varepsilon  &gt;0</tex>, il existe <tex>\delta  &gt; 0</tex> tel que <tex display="block">\lvert  x - a \rvert  &lt;  \delta   \implies   \lvert  f(x) - f(a) \rvert  &lt;  \varepsilon</tex></li></ol></mainmatter> </tree><p>Cette dernière propriété motive la notion d'ouvert de <tex>\mathbb {R}</tex> : l'image réciproque d'un voisinage de <tex>f(a)</tex> doit être un voisinage de <tex>a</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>876</anchor>  <taxon>Définition</taxon> <addr>cs-000K</addr>  <route>cs-000K.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Ouvert de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><p>Une partie <tex>A  \subset   \mathbb {R}</tex> est dite ouverte quand pour tout <tex>a \in  A</tex>, il existe <tex>\varepsilon</tex> tel que <tex display="block">\lvert   x-a \rvert  &lt;  \varepsilon   \implies  x  \in  A</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>877</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>878</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>879</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>880</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>881</anchor>   <addr>cs-000A</addr>  <route>cs-000A.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Calcul différentiel</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>882</anchor>   <addr>cs-0005</addr>  <route>cs-0005.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Théorie des groupes</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>883</anchor>   <addr>cs-0009</addr>  <route>cs-0009.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>884</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>885</anchor>  <taxon>Définition</taxon> <addr>cs-000O</addr>  <route>cs-000O.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>  </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>886</anchor>  <taxon>Remarque</taxon> <addr>cs-000P</addr>  <route>cs-000P.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>    </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>887</anchor>  <taxon>Définition</taxon> <addr>cs-000N</addr>  <route>cs-000N.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>888</anchor>  <taxon>Exemples</taxon> <addr>cs-000Q</addr>  <route>cs-000Q.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>  </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>889</anchor>  <taxon>Lemme</taxon> <addr>cs-000R</addr>  <route>cs-000R.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>  </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>890</anchor>  <taxon>Définition</taxon> <addr>cs-000S</addr>  <route>cs-000S.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>  </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>891</anchor>  <taxon>Exemple</taxon> <addr>cs-000T</addr>  <route>cs-000T.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>  </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>892</anchor>  <taxon>Définition</taxon> <addr>cs-000X</addr>  <route>cs-000X.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>  </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>893</anchor>  <taxon>Définition</taxon> <addr>cs-000Y</addr>  <route>cs-000Y.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>894</anchor>  <taxon>Définition</taxon> <addr>cs-000Z</addr>  <route>cs-000Z.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>895</anchor>  <taxon>Proposition</taxon> <addr>cs-000U</addr>  <route>cs-000U.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>  </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>896</anchor>  <taxon>Corollaire</taxon> <addr>cs-000W</addr>  <route>cs-000W.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>  </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>897</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>898</anchor>  <taxon>Exemples</taxon> <addr>cs-000V</addr>  <route>cs-000V.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>  </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>899</anchor>  <taxon>Proposition</taxon> <addr>cs-0010</addr>  <route>cs-0010.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>  </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \cdots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \cdots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \cdots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \cdots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>900</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>901</anchor>  <taxon>Lemme</taxon> <addr>cs-0011</addr>  <route>cs-0011.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>902</anchor>  <taxon>Corollaire</taxon> <addr>cs-0012</addr>  <route>cs-0012.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>  </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>903</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>904</anchor>  <taxon>Remarque</taxon> <addr>cs-0013</addr>  <route>cs-0013.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>905</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>906</anchor>  <taxon>Définition</taxon> <addr>cs-0014</addr>  <route>cs-0014.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>907</anchor>  <taxon>Définition</taxon> <addr>cs-0015</addr>  <route>cs-0015.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>908</anchor>  <taxon>Propriété</taxon> <addr>cs-0016</addr>  <route>cs-0016.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>    </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>909</anchor>   <addr>cs-0006</addr>  <route>cs-0006.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Variétés et schémas</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>910</anchor>   <addr>cs-0017</addr>  <route>cs-0017.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Le schéma affine <tex>\mathrm {Spec}  \,  A</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>911</anchor>   <addr>cs-0018</addr>  <route>cs-0018.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>La topologie de Zariski sur <tex>\mathrm {Spec}  \,  A</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>912</anchor>  <taxon>Définition</taxon> <addr>cs-001C</addr>  <route>cs-001C.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Spectre premier d'un anneau</title>  </frontmatter> <mainmatter><p>Soit <tex>A</tex> un anneau commutatif. On note <tex>\mathrm {Spec}  \,  A</tex> l'ensemble des <link href="cs-0014.xml" type="local" addr="cs-0014" title="Idéal premier">idéaux premiers</link> de <tex>A</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>913</anchor>  <taxon>Définition</taxon> <addr>cs-001A</addr>  <route>cs-001A.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title><tex>V(I)</tex></title>  </frontmatter> <mainmatter><p>Étant donné un idéal quelconque <tex>I  \subset  A</tex>, on note <tex display="block">V(I) =  \{  P  \in   \mathrm {Spec}  \,  A  \mid  I  \subset  P  \}</tex></p>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>914</anchor>  <taxon>Exemple</taxon> <addr>cs-001B</addr>  <route>cs-001B.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title/>  </frontmatter> <mainmatter><p>Si <tex>A = k[X]</tex> et <tex>I = (P)</tex>, <tex display="block">V(I) =  \{ Q  \in  k[X] | Q  \text { divise }P  \text { et } Q  \text { irréductible} \}</tex>Si de plus <tex>k</tex> est algébriquement clos, <tex>V(I) =  \{  X- \alpha  | P( \alpha ) = 0  \}</tex></p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>915</anchor>  <taxon>Proposition</taxon> <addr>cs-001D</addr>  <route>cs-001D.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Topologie de Zariski</title>  </frontmatter> <mainmatter><p>On peut définir une topologie sur <tex>\mathrm {Spec}  \,  A</tex>  en posant <tex display="block">F  \subset   \mathrm {Spec}  \,  A  \text { est fermé}  \iff   \exists  I  \text { idéal de }A, F = V(I)</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>916</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter>
  <ol><li>Remarquons d’abord que <tex>\mathrm {Spec}  \,  A</tex> est bien un fermé avec <tex>I = (0)</tex> et <tex>\varnothing</tex> aussi avec <tex>I = A</tex>.</li>
<li>Soient deux idéaux <tex>I</tex> et <tex>J</tex>. Montrons que <tex>V(I)  \cup  V(J) =V(IJ)</tex> donc est aussi un fermé. Il est clair que si <tex>P</tex> est un idéal (premier) qui contient <tex>I</tex> et <tex>J</tex>, alors il contient leur produit. Réciproquement si <tex>P</tex> est un idéal premier qui conduit <tex>IJ</tex>, alors il doit contenir <tex>I</tex> ou <tex>J</tex> : supposons en effet qu’il ne contienne pas <tex>J</tex>. Alors il existe <tex>j  \in  J</tex> tel que <tex>j  \not \in  P</tex>. Mais <tex>P</tex> contient tous les produits <tex>ij</tex> pour <tex>i  \in  I</tex>, donc comme il est premier et ne contient pas <tex>j</tex> il doit contenir <tex>i</tex>.</li>
<li>Soit une famille d’idéaux <tex>(I_{x})_{x  \in  X}</tex>. Montrons que <tex display="block">\bigcap _{x  \in  X} V(I_{x}) = V \left ( \sum _{x  \in  X} I_{x}  \right )</tex>En effet par définition la somme des <tex>I_x</tex> est le plus petit idéal qui les contient tous. Donc <tex>P</tex> idéal contient <tex>\sum  I_x</tex>  si et seulement si il contient chaque <tex>I_x.</tex></li></ol>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>917</anchor>  <taxon>Proposition</taxon> <addr>cs-001E</addr>  <route>cs-001E.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Une base de la topologie de Zariski</title>  </frontmatter> <mainmatter><p>Pour <tex>f  \in  A</tex>, on pose <tex>D(f)</tex> le complémentaire de <tex>V((f))</tex>. Les <tex>D(f)</tex> forment une <link href="todo.xml" type="local" addr="todo" title="À faire">base</link> de la topologie de Zariski.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>918</anchor>   <addr>cs-0019</addr>  <route>cs-0019.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Le faisceau structural <tex>\mathcal {O}_{ \mathrm {Spec}  \,  A}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>919</anchor>  <taxon>Définition</taxon> <addr>cs-001F</addr>  <route>cs-001F.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title><tex>\mathcal {O}_{ \mathrm {Spec}  \,  A}</tex></title>  </frontmatter> <mainmatter><p>Pour <tex>U</tex> un ouvert pour la topologie de Zariski, on pose
<tex display="block">\mathcal {O}(U) :=  \left \{   s : U  \to   \bigsqcup _{P  \in  U} A_{P} { \,   \Huge  |  \, }  \begin {matrix}  \forall  P  \in  U, s(P)  \in  A_{P}  \\   \forall  P  \in  U,  \exists  (a,f)  \in  A^{2},  \text { sur un voisinage de }P, s= \frac {a}{f}    \end {matrix}  \right \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>920</anchor>  <taxon>Proposition</taxon> <addr>cs-001G</addr>  <route>cs-001G.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter><p><tex>\mathcal {O} : U  \mapsto   \mathcal {O}(U)</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">faisceau</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>921</anchor>  <taxon>Proposition</taxon> <addr>cs-001H</addr>  <route>cs-001H.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter><p>Pour tout <tex>P  \in   \mathrm {Spec}  \,  A</tex>, la fibre <tex>\mathcal {O}_{P}</tex> est isomorphe à la localisation <tex>A_{P}</tex> par <tex>\varphi  : s  \mapsto  s(P)</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>922</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter>
  <ol><li><tex>\varphi</tex> est surjectif : tout élément de <tex>A_{P}</tex> est de la forme <tex>\frac {a}{f}</tex> où <tex>f \not \in  P</tex>. Alors <tex>D(f)</tex> est un voisinage de <tex>P</tex>, et <tex>\frac {a}{p}  \in   \mathcal {O}(D(f))</tex> a bien pour valeur <tex>\frac {a}{f}</tex> en <tex>A_{P}</tex>.</li>
  <li><tex>\varphi</tex> est injectif : soit deux sections <tex>s,t  \in   \mathcal {O}(U)</tex> ayant la même valeur en <tex>P</tex>. Sur un voisinage <tex>U’</tex> de <tex>P</tex>, on peut écrire <tex>s =  \frac {a}{f}</tex> et <tex>t =  \frac {b}{g}</tex>. Donc <tex>\frac {a}{f}</tex> et <tex>\frac {b}{g}</tex> on même image dans <tex>A_{P}</tex>, autrement dit <tex display="block">\exists  h  \in  P, h(ga-fb) = 0</tex>Mais alors pour tout <tex>Q</tex> tel que <tex>h, g</tex> et <tex>f  \not \in  Q</tex>, on a <tex>s(Q) = t(Q)</tex>. Donc <tex>V(g)  \cap  V(h)  \cap  V(f)</tex> est un voisinage de <tex>P</tex> sur lequel <tex>s</tex> et <tex>t</tex> coïncident. Elles ont donc même germe.</li></ol>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>923</anchor>  <taxon>Proposition</taxon> <addr>cs-001I</addr>  <route>cs-001I.xml</route> <date><year>2024</year> <month>2</month> <day>28</day></date>    </frontmatter> <mainmatter><p>Pour tout <tex>f  \in  A</tex>, <tex>\mathcal {O}(D(f))  \cong  A_f</tex> par en envoyant la fraction <tex>\frac {a}{f^n}</tex> sur la fonction régulière <tex>\frac {a}{f^n}</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
  <span style="display: none"><p><link href="hartshorne-ag.xml" type="local" addr="hartshorne-ag" title="Algebraic Geometry">AG</link> <link href="eisenbud-calg.xml" type="local" addr="eisenbud-calg" title="Commutative algebra with a view towards algebraic geometry">Calg</link></p></span>
</mainmatter> </tree>
</mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>
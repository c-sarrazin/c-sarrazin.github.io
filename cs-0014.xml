<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>694</anchor> <taxon>Définition</taxon> <addr>cs-0014</addr><route>cs-0014.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>695</anchor>  <addr>cs-0009</addr><route>cs-0009.xml</route>  <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>696</anchor> <taxon>Définition</taxon> <addr>cs-000M</addr><route>cs-000M.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>   </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>697</anchor> <taxon>Définition</taxon> <addr>cs-000O</addr><route>cs-000O.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>   </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>698</anchor> <taxon>Remarque</taxon> <addr>cs-000P</addr><route>cs-000P.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>     </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>699</anchor> <taxon>Définition</taxon> <addr>cs-000N</addr><route>cs-000N.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>700</anchor> <taxon>Exemples</taxon> <addr>cs-000Q</addr><route>cs-000Q.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>   </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>701</anchor> <taxon>Lemme</taxon> <addr>cs-000R</addr><route>cs-000R.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>   </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>702</anchor> <taxon>Définition</taxon> <addr>cs-000S</addr><route>cs-000S.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>   </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>703</anchor> <taxon>Exemple</taxon> <addr>cs-000T</addr><route>cs-000T.xml</route>  <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>   </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>704</anchor> <taxon>Définition</taxon> <addr>cs-000X</addr><route>cs-000X.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>   </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>705</anchor> <taxon>Définition</taxon> <addr>cs-000Y</addr><route>cs-000Y.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>   </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>706</anchor> <taxon>Définition</taxon> <addr>cs-000Z</addr><route>cs-000Z.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>   </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>707</anchor> <taxon>Proposition</taxon> <addr>cs-000U</addr><route>cs-000U.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>   </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>708</anchor> <taxon>Corollaire</taxon> <addr>cs-000W</addr><route>cs-000W.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>   </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>709</anchor> <taxon>Preuve</taxon>   <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>710</anchor> <taxon>Exemples</taxon> <addr>cs-000V</addr><route>cs-000V.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>   </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>711</anchor> <taxon>Proposition</taxon> <addr>cs-0010</addr><route>cs-0010.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>   </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \ots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \ots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \ots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \ots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>712</anchor> <taxon>Preuve</taxon>   <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>713</anchor> <taxon>Lemme</taxon> <addr>cs-0011</addr><route>cs-0011.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>714</anchor> <taxon>Corollaire</taxon> <addr>cs-0012</addr><route>cs-0012.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>   </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>715</anchor> <taxon>Preuve</taxon>   <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>716</anchor> <taxon>Remarque</taxon> <addr>cs-0013</addr><route>cs-0013.xml</route>  <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>717</anchor> <taxon>Preuve</taxon>   <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>718</anchor> <taxon>Définition</taxon> <addr>cs-0014</addr><route>cs-0014.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>719</anchor> <taxon>Définition</taxon> <addr>cs-0015</addr><route>cs-0015.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>720</anchor> <taxon>Propriété</taxon> <addr>cs-0016</addr><route>cs-0016.xml</route>  <date><year>2024</year> <month>2</month> <day>26</day></date>     </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>721</anchor> <taxon>Définition</taxon> <addr>cs-001C</addr><route>cs-001C.xml</route>  <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Spectre premier d'un anneau</title>   </frontmatter> <mainmatter><p>Soit <tex>A</tex> un anneau commutatif. On note <tex>\mathrm {Spec}  \,  A</tex> l'ensemble des <link href="cs-0014.xml" type="local" addr="cs-0014" title="Idéal premier">idéaux premiers</link> de <tex>A</tex>.</p></mainmatter> </tree></backlinks> <references/></backmatter></tree>
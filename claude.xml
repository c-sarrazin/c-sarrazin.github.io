<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1471</anchor>  <taxon>Person</taxon> <addr>claude</addr>  <route>claude.xml</route>   <title>Claude</title>  </frontmatter> <mainmatter><p>J'aime les mathématiques, les grenouilles et Cyprien.</p></mainmatter> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1472</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1473</anchor>  <taxon>Définition</taxon> <addr>cs-000L</addr>  <route>cs-000L.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Foncteur</title>  </frontmatter> <mainmatter><p>Soient <tex>\mathscr {C}</tex> et <tex>\mathscr {D}</tex> deux <link href="cs-0002.xml" type="local" addr="cs-0002" title="Catégorie">catégories</link>. Un <em>foncteur</em> (covariant) <tex>\mathcal {F}</tex> de <tex>\mathscr {C}</tex> vers <tex>\mathscr {D}</tex> associe :</p><ul><li>à tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex> un objet <tex>\mathcal {F}(x)  \in   \mathrm {Ob}( \mathscr {D})</tex>,</li>
  <li>à tout morphisme <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x, y)</tex> un morphisme <tex>\mathcal {F}(f)  \in   \mathrm {Hom}_{ \mathscr {D}}( \mathcal {F}(x),  \mathcal {F}(y))</tex>,</li></ul><p>tel que :</p><ul><li><tex>\mathcal {F}( \mathrm {Id}_x) =  \mathrm {Id}_{ \mathcal {F}(x)}</tex>,</li>
  <li>pour <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, <tex>\mathcal {F}(g  \circ  f) =  \mathcal {F}(g)  \circ   \mathcal {F}(f)</tex>.</li></ul></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1474</anchor>  <taxon>Définition</taxon> <addr>cs-000N</addr>  <route>cs-000N.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1475</anchor>  <taxon>Exemples</taxon> <addr>cs-000Q</addr>  <route>cs-000Q.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>  </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1476</anchor>   <addr>cs-0009</addr>  <route>cs-0009.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1477</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1478</anchor>  <taxon>Définition</taxon> <addr>cs-000O</addr>  <route>cs-000O.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>  </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1479</anchor>  <taxon>Remarque</taxon> <addr>cs-000P</addr>  <route>cs-000P.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>    </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1480</anchor>  <taxon>Définition</taxon> <addr>cs-000N</addr>  <route>cs-000N.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1481</anchor>  <taxon>Exemples</taxon> <addr>cs-000Q</addr>  <route>cs-000Q.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>  </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1482</anchor>  <taxon>Lemme</taxon> <addr>cs-000R</addr>  <route>cs-000R.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>  </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1483</anchor>  <taxon>Définition</taxon> <addr>cs-000S</addr>  <route>cs-000S.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>  </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1484</anchor>  <taxon>Exemple</taxon> <addr>cs-000T</addr>  <route>cs-000T.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>  </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1485</anchor>  <taxon>Définition</taxon> <addr>cs-000X</addr>  <route>cs-000X.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>  </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1486</anchor>  <taxon>Définition</taxon> <addr>cs-000Y</addr>  <route>cs-000Y.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1487</anchor>  <taxon>Définition</taxon> <addr>cs-000Z</addr>  <route>cs-000Z.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1488</anchor>  <taxon>Proposition</taxon> <addr>cs-000U</addr>  <route>cs-000U.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>  </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1489</anchor>  <taxon>Corollaire</taxon> <addr>cs-000W</addr>  <route>cs-000W.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>  </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1490</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1491</anchor>  <taxon>Exemples</taxon> <addr>cs-000V</addr>  <route>cs-000V.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>  </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1492</anchor>  <taxon>Proposition</taxon> <addr>cs-0010</addr>  <route>cs-0010.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>  </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \ots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \ots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \ots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \ots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1493</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1494</anchor>  <taxon>Lemme</taxon> <addr>cs-0011</addr>  <route>cs-0011.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1495</anchor>  <taxon>Corollaire</taxon> <addr>cs-0012</addr>  <route>cs-0012.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>  </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1496</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1497</anchor>  <taxon>Remarque</taxon> <addr>cs-0013</addr>  <route>cs-0013.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1498</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1499</anchor>  <taxon>Définition</taxon> <addr>cs-0014</addr>  <route>cs-0014.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1500</anchor>  <taxon>Définition</taxon> <addr>cs-0015</addr>  <route>cs-0015.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1501</anchor>  <taxon>Propriété</taxon> <addr>cs-0016</addr>  <route>cs-0016.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>    </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1502</anchor>   <addr>cs-0008</addr>  <route>cs-0008.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre linéaire</title>  </frontmatter> <mainmatter/> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1503</anchor>   <addr>cs-000A</addr>  <route>cs-000A.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Calcul différentiel</title>  </frontmatter> <mainmatter/> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1504</anchor>  <taxon>Définition</taxon> <addr>cs-0002</addr>  <route>cs-0002.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégorie</title>  </frontmatter> <mainmatter><p> Une <em>catégorie</em> <tex>\mathscr {C}</tex> est la donnée de :</p><ol><li>une collection d'objets <tex>\mathrm {Ob}( \mathscr {C})</tex>,</li>
  <li>pour toute paire d'objets <tex>x, y  \in   \mathrm {Ob}( \mathscr {C})</tex>, une collection de morphismes <tex>\mathrm {Hom}_{ \mathscr {C}}(x,y)</tex>,</li></ol><p>telle que :</p><ol><li>pour tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex>, on ait un morphisme <tex>\mathrm {Id}_x  \in   \mathrm {Hom}_{ \mathscr {C}}(x,x)</tex>,</li>
  <li>pour tous morphismes <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, on ait un morphisme <tex>g  \circ  f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,z)</tex></li></ol><p>tels que le diagramme suivant commute :</p>
 <embedded-tex hash="3ff8e05116b4e159509dfb442821e0a3"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
 \begin {tikzcd}
w  \arrow [r, &quot;f&quot;]  \arrow [rr, &quot;g  \circ  f&quot;, bend left=49]  \arrow [&quot; \mathrm {Id}_w&quot;', loop, distance=2em, in=305, out=235] &amp; x  \arrow [r, &quot;g&quot;]  \arrow [rr, &quot;h  \circ  g&quot;, bend right=49] &amp; y  \arrow [r, &quot;h&quot;] &amp; z  \arrow [&quot; \mathrm {Id}_z&quot;', loop, distance=2em, in=125, out=55]
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<p>Autrement dit, la composition est associative, et composer par un morphisme identité n'a aucun effet.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1505</anchor>  <taxon>Exemples</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title/>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1506</anchor>   <addr>cs-0004</addr>  <route>cs-0004.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégories, foncteurs, jolis diagrammes</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1507</anchor>  <taxon>Définition</taxon> <addr>cs-0002</addr>  <route>cs-0002.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégorie</title>  </frontmatter> <mainmatter><p> Une <em>catégorie</em> <tex>\mathscr {C}</tex> est la donnée de :</p><ol><li>une collection d'objets <tex>\mathrm {Ob}( \mathscr {C})</tex>,</li>
  <li>pour toute paire d'objets <tex>x, y  \in   \mathrm {Ob}( \mathscr {C})</tex>, une collection de morphismes <tex>\mathrm {Hom}_{ \mathscr {C}}(x,y)</tex>,</li></ol><p>telle que :</p><ol><li>pour tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex>, on ait un morphisme <tex>\mathrm {Id}_x  \in   \mathrm {Hom}_{ \mathscr {C}}(x,x)</tex>,</li>
  <li>pour tous morphismes <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, on ait un morphisme <tex>g  \circ  f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,z)</tex></li></ol><p>tels que le diagramme suivant commute :</p>
 <embedded-tex hash="3ff8e05116b4e159509dfb442821e0a3"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
 \begin {tikzcd}
w  \arrow [r, &quot;f&quot;]  \arrow [rr, &quot;g  \circ  f&quot;, bend left=49]  \arrow [&quot; \mathrm {Id}_w&quot;', loop, distance=2em, in=305, out=235] &amp; x  \arrow [r, &quot;g&quot;]  \arrow [rr, &quot;h  \circ  g&quot;, bend right=49] &amp; y  \arrow [r, &quot;h&quot;] &amp; z  \arrow [&quot; \mathrm {Id}_z&quot;', loop, distance=2em, in=125, out=55]
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<p>Autrement dit, la composition est associative, et composer par un morphisme identité n'a aucun effet.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1508</anchor>  <taxon>Exemples</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title/>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1509</anchor>  <taxon>Définition</taxon> <addr>cs-000L</addr>  <route>cs-000L.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Foncteur</title>  </frontmatter> <mainmatter><p>Soient <tex>\mathscr {C}</tex> et <tex>\mathscr {D}</tex> deux <link href="cs-0002.xml" type="local" addr="cs-0002" title="Catégorie">catégories</link>. Un <em>foncteur</em> (covariant) <tex>\mathcal {F}</tex> de <tex>\mathscr {C}</tex> vers <tex>\mathscr {D}</tex> associe :</p><ul><li>à tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex> un objet <tex>\mathcal {F}(x)  \in   \mathrm {Ob}( \mathscr {D})</tex>,</li>
  <li>à tout morphisme <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x, y)</tex> un morphisme <tex>\mathcal {F}(f)  \in   \mathrm {Hom}_{ \mathscr {D}}( \mathcal {F}(x),  \mathcal {F}(y))</tex>,</li></ul><p>tel que :</p><ul><li><tex>\mathcal {F}( \mathrm {Id}_x) =  \mathrm {Id}_{ \mathcal {F}(x)}</tex>,</li>
  <li>pour <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, <tex>\mathcal {F}(g  \circ  f) =  \mathcal {F}(g)  \circ   \mathcal {F}(f)</tex>.</li></ul></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1510</anchor>  <taxon>Exemple</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Exemples de catégories</title>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1511</anchor>   <addr>cs-0007</addr>  <route>cs-0007.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie</title>  </frontmatter> <mainmatter><p>La topologie est l'étude des espaces les plus généraux possibles où étudier les notions de <link href="todo.xml" type="local" addr="todo" title="À faire">continuité</link> et de <link href="todo.xml" type="local" addr="todo" title="À faire">convergence</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1512</anchor>   <addr>cs-000H</addr>  <route>cs-000H.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Topologie de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1513</anchor>  <taxon>Définition</taxon> <addr>cs-000G</addr>  <route>cs-000G.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Convergence d'une suite réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>(u_n)</tex> une suite réelle. On dit qu'elle converge vers <tex>\ell</tex> quand <tex display="block">\forall   \varepsilon  &gt; 0,  \exists  N  \in   \mathbb {N}, n &gt; N  \implies   \lvert  u_n -  \ell   \rvert  &lt;  \varepsilon</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1514</anchor>  <taxon>Définition</taxon> <addr>cs-000I</addr>  <route>cs-000I.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Continuité d'une fonction réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>f : I  \to   \mathbb {R}</tex> une fonction réelle. On dit qu'elle est continue en <tex>a  \in   \mathbb {R}</tex> quand <tex display="block">\lim _{x \to  a} f(x) = f(a)</tex></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1515</anchor>  <taxon>Propriété</taxon> <addr>cs-000J</addr>  <route>cs-000J.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Caractérisations de la continuité</title>  </frontmatter> <mainmatter><p>Les conditions suivantes sont équivalentes :</p><ol><li><tex>f</tex> est continue en <tex>a</tex> ;</li>
  <li>Pour toute suite réelle <tex>(x_n)</tex> convergeant vers <tex>a</tex>, <tex>f(x_n)  \to  f(a)</tex> ;</li>
  <li>Pour tout <tex>\varepsilon  &gt;0</tex>, il existe <tex>\delta  &gt; 0</tex> tel que <tex display="block">\lvert  x - a \rvert  &lt;  \delta   \implies   \lvert  f(x) - f(a) \rvert  &lt;  \varepsilon</tex></li></ol></mainmatter> </tree><p>Cette dernière propriété motive la notion d'ouvert de <tex>\mathbb {R}</tex> : l'image réciproque d'un voisinage de <tex>f(a)</tex> doit être un voisinage de <tex>a</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1516</anchor>  <taxon>Définition</taxon> <addr>cs-000K</addr>  <route>cs-000K.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Ouvert de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><p>Une partie <tex>A  \subset   \mathbb {R}</tex> est dite ouverte quand pour tout <tex>a \in  A</tex>, il existe <tex>\varepsilon</tex> tel que <tex display="block">\lvert   x-a \rvert  &lt;  \varepsilon   \implies  x  \in  A</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1517</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1518</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1519</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1520</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1521</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1522</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1523</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1524</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1525</anchor>  <taxon>Entrée journalière</taxon> <addr>2024-03-07</addr>  <route>2024-03-07.xml</route>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Jeudi 7 mars</title>  <meta name="venue"/></frontmatter> <mainmatter>
  <span style="display: none"><p><link href="journal.xml" type="local" addr="journal" title="Journal mathématique">journal</link></p></span>
<p>Dans un effort de mieux comprendre les produits tensoriels :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1526</anchor>  <taxon>Exercice</taxon> <addr>cs-001O</addr>  <route>cs-001O.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Vakil, exercice 1.3.G</title>  </frontmatter> <mainmatter>
  <span style="display: none"><p><link href="vakil-foag.xml" type="local" addr="vakil-foag" title="The Rising Sea. Foundations of Algebraic Geometry">The Rising Sea. Foundations of Algebraic Geometry</link></p></span>
<p>Montrer que <tex>\mathbb {Z}  / 10 \mathbb {Z}   \otimes _{ \mathbb {Z} }  \mathbb {Z}  / 12 \mathbb {Z}   \cong   \mathbb {Z}  / 2 \mathbb {Z}</tex>.</p>
  
    
    
    <tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1527</anchor>  <taxon>Solution</taxon>    <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>    </frontmatter> <mainmatter>
  <p>On pose <tex>\varphi  : n  \otimes  m  \mapsto  nm [2]</tex>. Il est clair qu'il est bien défini et surjectif. Par ailleurs comme <tex>12-10 = 2</tex> on peut écrire <tex display="block">n  \otimes  2m = 12(n  \otimes  m) - 10(n  \otimes  m) = 0  \otimes  0</tex>d'où <tex>\varphi</tex> injectif et donc iso.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1528</anchor>   <addr>cs-001P</addr>  <route>cs-001P.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Sur les produits tensoriels</title>  </frontmatter> <mainmatter><p>Soit <tex>A</tex> un anneau commutatif.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1529</anchor>  <taxon>Définition</taxon> <addr>cs-001Q</addr>  <route>cs-001Q.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Produit tensoriel de <tex>A</tex>-modules</title>  </frontmatter> <mainmatter><p>Soient <tex>M</tex> et <tex>M'</tex> deux <tex>A</tex>-modules. On note <tex>M  \otimes  M'</tex> un <tex>A</tex>-module muni de <tex>\pi  : M  \times  M'  \to  M  \otimes  M'</tex> qui a la propriété universelle suivante :</p><p>Pour toute application <tex>A</tex>-bilinéaire <tex>f : M  \times  M'  \to  N</tex>, il existe une unique application <tex>\tilde {f}</tex> <tex>A</tex>-linéaire telle que le diagramme suivant commute :</p>
 <embedded-tex hash="76514736154ec0c7daa2eaea104973a9"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
 \begin {tikzcd}[sep=3em]
M  \times  M'  \arrow [d, &quot; \pi &quot;]  \arrow [rd, &quot;f&quot;]  &amp;    \\ 
M  \otimes  M'  \arrow [r, &quot; \tilde {f}&quot;, dashed] &amp; N
 \end {tikzcd}
</embedded-tex-body></embedded-tex>

  
    
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1530</anchor>  <taxon>Construction</taxon>    <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>    </frontmatter> <mainmatter>
  <p>On quotiente le module libre engendré par les éléments <tex>m  \otimes  n</tex> par le sous-module engendré par les éléments de la forme</p> 
  <ul><li><tex>(m_1 +m_2)  \otimes  n - m_1  \otimes  n - m_2  \otimes  n</tex></li>
    <li><tex>m  \otimes  (n_1+n_2) - m  \otimes  n_1 - m  \otimes  n_2</tex></li>
    <li><tex>a(m \otimes  n) - (am)  \otimes  n</tex></li>
    <li><tex>a(m \otimes  n) - m  \otimes  (an)</tex></li></ul>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1531</anchor>  <taxon>Proposition</taxon> <addr>cs-001R</addr>  <route>cs-001R.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Le produit tensoriel est exact à droite</title>  </frontmatter> <mainmatter><p>Soit <tex>N</tex> un <tex>A</tex>-module. On a un foncteur covariant <tex display="block">-  \otimes  N: M  \mapsto  M  \otimes  N </tex>
Ce foncteur est exact à droite, i.e. transforme une suite exacte <tex display="block">M'  \to  M  \to  M''  \to  0</tex> en une suite exacte <tex display="block">M'  \otimes  N  \to  M  \otimes  N  \to  M''  \otimes  N  \to  0</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1532</anchor>  <taxon>Entrée journalière</taxon> <addr>2024-03-04</addr>  <route>2024-03-04.xml</route>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Lundi 4 mars</title>  <meta name="venue">où l'on explique ce que l'on attend d'un journal mathématique</meta></frontmatter> <mainmatter><p>Aujourd'hui j'ai créé ce journal avec Forester. Le but est de documenter l'avancement quotidien du schmilblick, en particulier :</p><ul><li>les divers faits sur lesquels je tombe et turbine,</li>
  <li>les exemples éclairants,</li>
  <li>les choses des cours.</li></ul><p>Pas de mathématiques aujourd'hui.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1533</anchor>  <taxon>Entrée journalière</taxon> <addr>2024-03-06</addr>  <route>2024-03-06.xml</route>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Mercredi 6 mars</title>  <meta name="venue">où l'on avance sur le chemin des faisceaux cohérents.</meta></frontmatter> <mainmatter>
  <span style="display: none"><p><link href="journal.xml" type="local" addr="journal" title="Journal mathématique">journal</link></p></span>
<p>Le but - chimérique - de ces prochains jours est d'avancer vers une compréhension du théorème GAGA. Je lisl'article original de Serre, <link href="serre-gaga.xml" type="local" addr="serre-gaga" title="Géométrie algébrique et géométrie analytique">Géométrie algébrique et géométrie analytique</link> ; mais d'abord il faudrait que je sache ce qu'est un faisceau cohérent et à quoi ça sert la cohomologie des faisceaux cohérents...
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1534</anchor>  <taxon>Définition</taxon> <addr>cs-001K</addr>  <route>cs-001K.xml</route> <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>  <title>Sous-ensemble analytique de <tex>\mathbb {C}^n</tex></title>  </frontmatter> <mainmatter><p><tex>U  \subset   \mathbb {C}^n</tex> est dit analytique quand pour tout <tex>x \in  U</tex>, il existe un voisinage <tex>W  \ni  x</tex> et des fonctions <tex>f_1, f_k</tex> holomorphes sur <tex>W</tex> telles que <tex display="block">U \cap  W =  \{ z \in  W  \mid  f_i(z) = 0,  \forall  i \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1535</anchor>       <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title><link href="2024-03-06.xml" type="local" addr="2024-03-06" title="Mercredi 6 mars">Mercredi 6 mars</link> › Les faisceaux selon Serre</title> <parent>2024-03-06</parent> </frontmatter> <mainmatter><p>Je suis ici <link href="serre-fac.xml" type="local" addr="serre-fac" title="Faisceaux algébriques cohérents">Faisceaux algébriques cohérents</link> car les définitions sont un peu différentes de <link href="todo.xml" type="local" addr="todo" title="À faire">celles auquelles je suis habituée</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1536</anchor>  <taxon>Définition</taxon>     <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Faisceau de groupes abéliens</title>  </frontmatter> <mainmatter><p>Un faisceau de groupes abéliens <tex>  \mathscr {F} </tex> sur un espace topologique <tex>X</tex> est la donnée d'un groupe abélien <tex>  \mathscr {F}_x </tex> pour tout <tex>x \in  X</tex> et d'une topologie sur <tex>  \bigsqcup _x  \mathscr {F}_x.</tex></p><p>On note alors <tex>\pi  : y  \in   \mathscr {F}_x  \mapsto  x</tex> et <tex>  \mathscr {F} +  \mathscr {F} =  \bigsqcup _x  \mathscr {F}_x  \times   \mathscr {F}_x </tex>.</p><p>Il faut de plus :</p><ol><li><tex>\pi</tex> est un homéomorphisme local ;</li>
    <li><tex>f  \mapsto  -f</tex> et <tex>(f, g)  \mapsto  f+g</tex> sont des applications continues respectivement de <tex>  \mathscr {F} </tex> dans <tex>  \mathscr {F} </tex> et de <tex>  \mathscr {F} +  \mathscr {F} </tex> dans <tex>  \mathscr {F} </tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1537</anchor>  <taxon>Définition</taxon>     <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Section</title>  </frontmatter> <mainmatter><p>Si <tex>U  \subset  X</tex> est un ouvert, on note <tex>\Gamma (U,  \mathscr {F})</tex> les sections de <tex>  \mathscr {F} </tex> au dessus de <tex>U</tex>, i.e. les applications continues <tex>s : U  \to   \mathscr {F}</tex> telles que <tex>\pi   \circ  s =  \mathrm {Id}_U</tex>.</p></mainmatter> </tree><p>Les morphismes de restriction évidents permettent de retrouver la définition usuelle d'un faisceau ; <tex>  \mathscr {F}_x </tex> correspond bien à la limite inductive des <tex>  \Gamma (U,  \mathscr {F}) </tex> sur les voisinages de <tex>x</tex> : c'est montré dans la section §1.3 de FAC.</p></mainmatter> </tree><p>Il y a un parallèle visible dans cette définition avec les fibrés vectoriels a.k.a les faisceaux localement libres de rang fini :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1538</anchor>  <taxon>Définition</taxon> <addr>cs-001M</addr>  <route>cs-001M.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Fibré vectoriel</title>  </frontmatter> <mainmatter><p>Un fibré vectoriel (réel) sur un espace topologique <tex>X</tex> est la donnée :</p><ul><li>d'un espace topologique <tex>E</tex> dit espace total,</li>
  <li>d'une application continue et surjective <tex>\pi  : E  \to  X</tex>,</li></ul><p>tel que <tex>\pi ^{-1}(x)</tex> a une structure d'espace vectoriel de dimension finie pour tout <tex>x \in  X</tex>, et que localement <tex>E</tex> ressemble au fibré trivial, i.e. pour tout <tex>x \in  X</tex> on a un voisinage <tex>U \ni  x</tex>, <tex>k  \in   \mathbb {N}</tex> et un homéomorphisme <tex display="block">\varphi  : U  \times   \mathbb {R}^k  \to   \pi ^{-1}(U)</tex> tel que <tex>\forall   \tilde {x}  \in  U</tex>:</p><ul><li><tex>\pi   \circ   \varphi ( \tilde {x}, v) = \tilde {x}</tex>, </li>
  <li><tex>\varphi ( \tilde {x}, -)</tex> est un isomorphisme entre <tex>\mathbb {R}</tex> et <tex>\pi ^{-1}( \{ \tilde {x} \} )</tex>.</li></ul></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1539</anchor>  <taxon>Théorème</taxon> <addr>cs-001N</addr>  <route>cs-001N.xml</route> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Une équivalence de catégories</title>  </frontmatter> <mainmatter><p>Soit <tex>X</tex> une variété réelle lisse. Soit <tex>\pi  : E  \to  X</tex> un fibré vectoriel. Une section de <tex>\pi</tex> au dessus d'un ouvert <tex>U \subset  X</tex> est une fonction continue <tex>s: U  \to  E</tex> tel que <tex>\pi   \circ  s =  \mathrm {Id}_U</tex>.</p><ul><li>Les sections de <tex>\pi</tex> forment un faisceau localement libre de rang fini de <tex>\mathscr {O}_M</tex>-modules, <tex>  \mathscr {F}_{ \pi } </tex>.</li>
  <li>Le foncteur qui à <tex>  \pi  </tex> associe <tex>\mathscr {F}_{ \pi }</tex> est une équivalence de catégories entre fibrés vectoriels et faisceaux localement libres de rang fini sur <tex>X</tex>.</li></ul>
  
    
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1540</anchor>  <taxon>Remarque</taxon>    <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>    </frontmatter> <mainmatter>
  <p>On a le <link href="todo.xml" type="local" addr="todo" title="À faire">même théorème</link> en remplaçant <tex>(M,  \mathscr {O}_M)</tex> par un schéma. Par contre je crois que pour un espace annelé en général ça ne marche pas.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><p>C'est ici qu'interviennent les faisceaux quasi-cohérents et cohérents : on voudrait avoir une <link href="cs-001T.xml" type="local" addr="cs-001T" title="Catégorie abélienne">catégorie abélienne</link> pour utiliser la machinerie de l'algèbre homologique.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1541</anchor>  <taxon>Exemple</taxon> <addr>cs-001S</addr>  <route>cs-001S.xml</route> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title>Les fibrés vectoriels ne forment pas une catégorie abélienne</title>  </frontmatter> <mainmatter><p>Considérons <tex>\pi  :  \mathbb {R}  \times   \mathbb {R}  \to   \mathbb {R}</tex> le fibré de droites trivial. Considérons le morphisme <tex>f :  \mathbb {R}  \times   \mathbb {R}  \to   \mathbb {R}  \times   \mathbb {R}</tex> qui à <tex>(t, v)</tex> associe <tex>(t, tv)</tex>. Le noyau de ce morphisme n'est pas un fibré vectoriel : en <tex>t = 0</tex> il serait de rang 1, et partout ailleurs de rang nul.</p></mainmatter> </tree><p>Je commence à me faire chier ; en guise de motivation je veux comprendre comment appliquer GAGA pour trouver Chow entre autres trucs sympas. D'où :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1542</anchor>   <addr>cs-001L</addr>  <route>cs-001L.xml</route> <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>  <title>Théorème de Chow</title>  </frontmatter> <mainmatter><p>Soit <tex> X  \subset   \mathbb {P}^n </tex> une sous-variété analytique fermée. Alors <tex> X </tex> est en fait une variété algébrique.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1543</anchor>  <taxon>Preuve</taxon>    <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>    </frontmatter> <mainmatter><p>Le faisceau des fonctions holomorphes sur <tex>X</tex> est cohérent ; c'est le théorème d'Oka. Donc si on l'étend en <tex>  \tilde { \mathscr {H}} </tex>sur tout <tex>  \mathbb {P}^n </tex> par des zéros (i.e. pour <tex>x  \not \in  X,  \mathscr {F}_x =  \{ 0 \}  </tex>) il est encore cohérent sur <tex>  \mathbb {P}^n </tex>.</p><p>D'après GAGA, il existe un faisceau algébrique cohérent <tex>\mathscr {F}</tex> sur <tex>  \mathbb {P}^n </tex> tel que <tex>  \mathscr {F}^{ \mathrm {an}} </tex> soit isomorphe à <tex>\tilde { \mathscr {H}}</tex>.</p><p>Comme <tex>  \mathscr {F} </tex> et <tex>\mathscr {F}^{ \mathrm {an}}</tex> ont même support, et que le support de <tex>\mathscr {F}^{ \mathrm {an}}</tex> est par définition <tex>X</tex>, <tex>X</tex> est le support du faisceau algébrique cohérent <tex>  \mathscr {F} </tex> et donc fermé pour la topologie de Zariski, i.e. une sous-variété algébrique de <tex>\mathbb {P}^n</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1544</anchor>   <addr>index</addr>  <route>index.xml</route>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Sofia</title>  </frontmatter> <mainmatter><p class="startpage" style="display: none">hihi</p><p>Sofia est une &quot;forêt&quot; crée avec <link href="http://www.jonmsterling.com/jms-005P.xml" type="external">Forester</link>. Elle rassemble mes notes de maths et mon <link href="journal.xml" type="local" addr="journal" title="Journal mathématique">journal mathématique</link> depuis janvier 2024. La plupart de ces notes sont transférées depuis Mimi, coffre <link href="https://obsidian.md" type="external">Obsidian</link> ayant vécu de 2021 à 2024. Repose en paix, Mimi.</p><p>Quelques points de départ de mes notes :</p>


<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1545</anchor>   <addr>cs-0004</addr>  <route>cs-0004.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégories, foncteurs, jolis diagrammes</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1546</anchor>  <taxon>Définition</taxon> <addr>cs-0002</addr>  <route>cs-0002.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Catégorie</title>  </frontmatter> <mainmatter><p> Une <em>catégorie</em> <tex>\mathscr {C}</tex> est la donnée de :</p><ol><li>une collection d'objets <tex>\mathrm {Ob}( \mathscr {C})</tex>,</li>
  <li>pour toute paire d'objets <tex>x, y  \in   \mathrm {Ob}( \mathscr {C})</tex>, une collection de morphismes <tex>\mathrm {Hom}_{ \mathscr {C}}(x,y)</tex>,</li></ol><p>telle que :</p><ol><li>pour tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex>, on ait un morphisme <tex>\mathrm {Id}_x  \in   \mathrm {Hom}_{ \mathscr {C}}(x,x)</tex>,</li>
  <li>pour tous morphismes <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, on ait un morphisme <tex>g  \circ  f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,z)</tex></li></ol><p>tels que le diagramme suivant commute :</p>
 <embedded-tex hash="3ff8e05116b4e159509dfb442821e0a3"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
 \begin {tikzcd}
w  \arrow [r, &quot;f&quot;]  \arrow [rr, &quot;g  \circ  f&quot;, bend left=49]  \arrow [&quot; \mathrm {Id}_w&quot;', loop, distance=2em, in=305, out=235] &amp; x  \arrow [r, &quot;g&quot;]  \arrow [rr, &quot;h  \circ  g&quot;, bend right=49] &amp; y  \arrow [r, &quot;h&quot;] &amp; z  \arrow [&quot; \mathrm {Id}_z&quot;', loop, distance=2em, in=125, out=55]
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<p>Autrement dit, la composition est associative, et composer par un morphisme identité n'a aucun effet.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1547</anchor>  <taxon>Exemples</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title/>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1548</anchor>  <taxon>Définition</taxon> <addr>cs-000L</addr>  <route>cs-000L.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Foncteur</title>  </frontmatter> <mainmatter><p>Soient <tex>\mathscr {C}</tex> et <tex>\mathscr {D}</tex> deux <link href="cs-0002.xml" type="local" addr="cs-0002" title="Catégorie">catégories</link>. Un <em>foncteur</em> (covariant) <tex>\mathcal {F}</tex> de <tex>\mathscr {C}</tex> vers <tex>\mathscr {D}</tex> associe :</p><ul><li>à tout objet <tex>x  \in   \mathrm {Ob}( \mathscr {C})</tex> un objet <tex>\mathcal {F}(x)  \in   \mathrm {Ob}( \mathscr {D})</tex>,</li>
  <li>à tout morphisme <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x, y)</tex> un morphisme <tex>\mathcal {F}(f)  \in   \mathrm {Hom}_{ \mathscr {D}}( \mathcal {F}(x),  \mathcal {F}(y))</tex>,</li></ul><p>tel que :</p><ul><li><tex>\mathcal {F}( \mathrm {Id}_x) =  \mathrm {Id}_{ \mathcal {F}(x)}</tex>,</li>
  <li>pour <tex>f  \in   \mathrm {Hom}_{ \mathscr {C}}(x,y)</tex> et <tex>g  \in   \mathrm {Hom}_{ \mathscr {C}}(y,z)</tex>, <tex>\mathcal {F}(g  \circ  f) =  \mathcal {F}(g)  \circ   \mathcal {F}(f)</tex>.</li></ul></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1549</anchor>   <addr>cs-0008</addr>  <route>cs-0008.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre linéaire</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1550</anchor>   <addr>cs-0007</addr>  <route>cs-0007.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie</title>  </frontmatter> <mainmatter><p>La topologie est l'étude des espaces les plus généraux possibles où étudier les notions de <link href="todo.xml" type="local" addr="todo" title="À faire">continuité</link> et de <link href="todo.xml" type="local" addr="todo" title="À faire">convergence</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1551</anchor>   <addr>cs-000H</addr>  <route>cs-000H.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Topologie de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1552</anchor>  <taxon>Définition</taxon> <addr>cs-000G</addr>  <route>cs-000G.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Convergence d'une suite réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>(u_n)</tex> une suite réelle. On dit qu'elle converge vers <tex>\ell</tex> quand <tex display="block">\forall   \varepsilon  &gt; 0,  \exists  N  \in   \mathbb {N}, n &gt; N  \implies   \lvert  u_n -  \ell   \rvert  &lt;  \varepsilon</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1553</anchor>  <taxon>Définition</taxon> <addr>cs-000I</addr>  <route>cs-000I.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Continuité d'une fonction réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>f : I  \to   \mathbb {R}</tex> une fonction réelle. On dit qu'elle est continue en <tex>a  \in   \mathbb {R}</tex> quand <tex display="block">\lim _{x \to  a} f(x) = f(a)</tex></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1554</anchor>  <taxon>Propriété</taxon> <addr>cs-000J</addr>  <route>cs-000J.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Caractérisations de la continuité</title>  </frontmatter> <mainmatter><p>Les conditions suivantes sont équivalentes :</p><ol><li><tex>f</tex> est continue en <tex>a</tex> ;</li>
  <li>Pour toute suite réelle <tex>(x_n)</tex> convergeant vers <tex>a</tex>, <tex>f(x_n)  \to  f(a)</tex> ;</li>
  <li>Pour tout <tex>\varepsilon  &gt;0</tex>, il existe <tex>\delta  &gt; 0</tex> tel que <tex display="block">\lvert  x - a \rvert  &lt;  \delta   \implies   \lvert  f(x) - f(a) \rvert  &lt;  \varepsilon</tex></li></ol></mainmatter> </tree><p>Cette dernière propriété motive la notion d'ouvert de <tex>\mathbb {R}</tex> : l'image réciproque d'un voisinage de <tex>f(a)</tex> doit être un voisinage de <tex>a</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1555</anchor>  <taxon>Définition</taxon> <addr>cs-000K</addr>  <route>cs-000K.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Ouvert de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><p>Une partie <tex>A  \subset   \mathbb {R}</tex> est dite ouverte quand pour tout <tex>a \in  A</tex>, il existe <tex>\varepsilon</tex> tel que <tex display="block">\lvert   x-a \rvert  &lt;  \varepsilon   \implies  x  \in  A</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1556</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1557</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1558</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1559</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1560</anchor>   <addr>cs-000A</addr>  <route>cs-000A.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Calcul différentiel</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1561</anchor>   <addr>cs-0005</addr>  <route>cs-0005.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Théorie des groupes</title>  </frontmatter> <mainmatter/> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1562</anchor>   <addr>cs-0009</addr>  <route>cs-0009.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1563</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1564</anchor>  <taxon>Définition</taxon> <addr>cs-000O</addr>  <route>cs-000O.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>  </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1565</anchor>  <taxon>Remarque</taxon> <addr>cs-000P</addr>  <route>cs-000P.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>    </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1566</anchor>  <taxon>Définition</taxon> <addr>cs-000N</addr>  <route>cs-000N.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1567</anchor>  <taxon>Exemples</taxon> <addr>cs-000Q</addr>  <route>cs-000Q.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>  </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1568</anchor>  <taxon>Lemme</taxon> <addr>cs-000R</addr>  <route>cs-000R.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>  </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1569</anchor>  <taxon>Définition</taxon> <addr>cs-000S</addr>  <route>cs-000S.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>  </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1570</anchor>  <taxon>Exemple</taxon> <addr>cs-000T</addr>  <route>cs-000T.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>  </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1571</anchor>  <taxon>Définition</taxon> <addr>cs-000X</addr>  <route>cs-000X.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>  </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1572</anchor>  <taxon>Définition</taxon> <addr>cs-000Y</addr>  <route>cs-000Y.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1573</anchor>  <taxon>Définition</taxon> <addr>cs-000Z</addr>  <route>cs-000Z.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1574</anchor>  <taxon>Proposition</taxon> <addr>cs-000U</addr>  <route>cs-000U.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>  </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1575</anchor>  <taxon>Corollaire</taxon> <addr>cs-000W</addr>  <route>cs-000W.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>  </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1576</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1577</anchor>  <taxon>Exemples</taxon> <addr>cs-000V</addr>  <route>cs-000V.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>  </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1578</anchor>  <taxon>Proposition</taxon> <addr>cs-0010</addr>  <route>cs-0010.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>  </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \ots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \ots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \ots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \ots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1579</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1580</anchor>  <taxon>Lemme</taxon> <addr>cs-0011</addr>  <route>cs-0011.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1581</anchor>  <taxon>Corollaire</taxon> <addr>cs-0012</addr>  <route>cs-0012.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>  </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1582</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1583</anchor>  <taxon>Remarque</taxon> <addr>cs-0013</addr>  <route>cs-0013.xml</route> <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1584</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1585</anchor>  <taxon>Définition</taxon> <addr>cs-0014</addr>  <route>cs-0014.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1586</anchor>  <taxon>Définition</taxon> <addr>cs-0015</addr>  <route>cs-0015.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1587</anchor>  <taxon>Propriété</taxon> <addr>cs-0016</addr>  <route>cs-0016.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>    </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1588</anchor>   <addr>cs-0006</addr>  <route>cs-0006.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Variétés et schémas</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1589</anchor>   <addr>cs-0017</addr>  <route>cs-0017.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Le schéma affine <tex>\mathrm {Spec}  \,  A</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1590</anchor>   <addr>cs-0018</addr>  <route>cs-0018.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>La topologie de Zariski sur <tex>\mathrm {Spec}  \,  A</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1591</anchor>  <taxon>Définition</taxon> <addr>cs-001C</addr>  <route>cs-001C.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Spectre premier d'un anneau</title>  </frontmatter> <mainmatter><p>Soit <tex>A</tex> un anneau commutatif. On note <tex>\mathrm {Spec}  \,  A</tex> l'ensemble des <link href="cs-0014.xml" type="local" addr="cs-0014" title="Idéal premier">idéaux premiers</link> de <tex>A</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1592</anchor>  <taxon>Définition</taxon> <addr>cs-001A</addr>  <route>cs-001A.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title><tex>V(I)</tex></title>  </frontmatter> <mainmatter><p>Étant donné un idéal quelconque <tex>I  \subset  A</tex>, on note <tex display="block">V(I) =  \{  P  \in   \mathrm {Spec}  \,  A  \mid  I  \subset  P  \}</tex></p>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1593</anchor>  <taxon>Exemple</taxon> <addr>cs-001B</addr>  <route>cs-001B.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title/>  </frontmatter> <mainmatter><p>Si <tex>A = k[X]</tex> et <tex>I = (P)</tex>, <tex display="block">V(I) =  \{ Q  \in  k[X] | Q  \text { divise }P  \text { et } Q  \text { irréductible} \}</tex>Si de plus <tex>k</tex> est algébriquement clos, <tex>V(I) =  \{  X- \alpha  | P( \alpha ) = 0  \}</tex></p></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1594</anchor>  <taxon>Proposition</taxon> <addr>cs-001D</addr>  <route>cs-001D.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Topologie de Zariski</title>  </frontmatter> <mainmatter><p>On peut définir une topologie sur <tex>\mathrm {Spec}  \,  A</tex>  en posant <tex display="block">F  \subset   \mathrm {Spec}  \,  A  \text { est fermé}  \iff   \exists  I  \text { idéal de }A, F = V(I)</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1595</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter>
  <ol><li>Remarquons d’abord que <tex>\mathrm {Spec}  \,  A</tex> est bien un fermé avec <tex>I = (0)</tex> et <tex>\varnothing</tex> aussi avec <tex>I = A</tex>.</li>
<li>Soient deux idéaux <tex>I</tex> et <tex>J</tex>. Montrons que <tex>V(I)  \cup  V(J) =V(IJ)</tex> donc est aussi un fermé. Il est clair que si <tex>P</tex> est un idéal (premier) qui contient <tex>I</tex> et <tex>J</tex>, alors il contient leur produit. Réciproquement si <tex>P</tex> est un idéal premier qui conduit <tex>IJ</tex>, alors il doit contenir <tex>I</tex> ou <tex>J</tex> : supposons en effet qu’il ne contienne pas <tex>J</tex>. Alors il existe <tex>j  \in  J</tex> tel que <tex>j  \not \in  P</tex>. Mais <tex>P</tex> contient tous les produits <tex>ij</tex> pour <tex>i  \in  I</tex>, donc comme il est premier et ne contient pas <tex>j</tex> il doit contenir <tex>i</tex>.</li>
<li>Soit une famille d’idéaux <tex>(I_{x})_{x  \in  X}</tex>. Montrons que <tex display="block">\bigcap _{x  \in  X} V(I_{x}) = V \left ( \sum _{x  \in  X} I_{x}  \right )</tex>En effet par définition la somme des <tex>I_x</tex> est le plus petit idéal qui les contient tous. Donc <tex>P</tex> idéal contient <tex>\sum  I_x</tex>  si et seulement si il contient chaque <tex>I_x.</tex></li></ol>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1596</anchor>  <taxon>Proposition</taxon> <addr>cs-001E</addr>  <route>cs-001E.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Une base de la topologie de Zariski</title>  </frontmatter> <mainmatter><p>Pour <tex>f  \in  A</tex>, on pose <tex>D(f)</tex> le complémentaire de <tex>V((f))</tex>. Les <tex>D(f)</tex> forment une <link href="todo.xml" type="local" addr="todo" title="À faire">base</link> de la topologie de Zariski.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1597</anchor>   <addr>cs-0019</addr>  <route>cs-0019.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Le faisceau structural <tex>\mathcal {O}_{ \mathrm {Spec}  \,  A}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1598</anchor>  <taxon>Définition</taxon> <addr>cs-001F</addr>  <route>cs-001F.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title><tex>\mathcal {O}_{ \mathrm {Spec}  \,  A}</tex></title>  </frontmatter> <mainmatter><p>Pour <tex>U</tex> un ouvert pour la topologie de Zariski, on pose
<tex display="block">\mathcal {O}(U) :=  \left \{   s : U  \to   \bigsqcup _{P  \in  U} A_{P} { \,   \Huge  |  \, }  \begin {matrix}  \forall  P  \in  U, s(P)  \in  A_{P}  \\   \forall  P  \in  U,  \exists  (a,f)  \in  A^{2},  \text { sur un voisinage de }P, s= \frac {a}{f}    \end {matrix}  \right \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1599</anchor>  <taxon>Proposition</taxon> <addr>cs-001G</addr>  <route>cs-001G.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter><p><tex>\mathcal {O} : U  \mapsto   \mathcal {O}(U)</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">faisceau</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1600</anchor>  <taxon>Proposition</taxon> <addr>cs-001H</addr>  <route>cs-001H.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter><p>Pour tout <tex>P  \in   \mathrm {Spec}  \,  A</tex>, la fibre <tex>\mathcal {O}_{P}</tex> est isomorphe à la localisation <tex>A_{P}</tex> par <tex>\varphi  : s  \mapsto  s(P)</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1601</anchor>  <taxon>Preuve</taxon>    <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter>
  <ol><li><tex>\varphi</tex> est surjectif : tout élément de <tex>A_{P}</tex> est de la forme <tex>\frac {a}{f}</tex> où <tex>f \not \in  P</tex>. Alors <tex>D(f)</tex> est un voisinage de <tex>P</tex>, et <tex>\frac {a}{p}  \in   \mathcal {O}(D(f))</tex> a bien pour valeur <tex>\frac {a}{f}</tex> en <tex>A_{P}</tex>.</li>
  <li><tex>\varphi</tex> est injectif : soit deux sections <tex>s,t  \in   \mathcal {O}(U)</tex> ayant la même valeur en <tex>P</tex>. Sur un voisinage <tex>U’</tex> de <tex>P</tex>, on peut écrire <tex>s =  \frac {a}{f}</tex> et <tex>t =  \frac {b}{g}</tex>. Donc <tex>\frac {a}{f}</tex> et <tex>\frac {b}{g}</tex> on même image dans <tex>A_{P}</tex>, autrement dit <tex display="block">\exists  h  \in  P, h(ga-fb) = 0</tex>Mais alors pour tout <tex>Q</tex> tel que <tex>h, g</tex> et <tex>f  \not \in  Q</tex>, on a <tex>s(Q) = t(Q)</tex>. Donc <tex>V(g)  \cap  V(h)  \cap  V(f)</tex> est un voisinage de <tex>P</tex> sur lequel <tex>s</tex> et <tex>t</tex> coïncident. Elles ont donc même germe.</li></ol>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1602</anchor>  <taxon>Proposition</taxon> <addr>cs-001I</addr>  <route>cs-001I.xml</route> <date><year>2024</year> <month>2</month> <day>28</day></date>    </frontmatter> <mainmatter><p>Pour tout <tex>f  \in  A</tex>, <tex>\mathcal {O}(D(f))  \cong  A_f</tex> par en envoyant la fraction <tex>\frac {a}{f^n}</tex> sur la fonction régulière <tex>\frac {a}{f^n}</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
  <span style="display: none"><p><link href="hartshorne-ag.xml" type="local" addr="hartshorne-ag" title="Algebraic Geometry">AG</link> <link href="eisenbud-calg.xml" type="local" addr="eisenbud-calg" title="Commutative algebra with a view towards algebraic geometry">Calg</link></p></span>
</mainmatter> </tree>
</mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1035</anchor>  <taxon>Lemme</taxon> <addr>cs-0011</addr>  <route>cs-0011.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>   </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1036</anchor>  <taxon>Preuve</taxon> <addr>cs-0010p</addr>  <route>cs-0010p.xml</route>    </frontmatter> <mainmatter><p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p><p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p><p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>
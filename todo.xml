<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1646</anchor> <taxon>Meta</taxon> <addr>todo</addr><route>todo.xml</route> <source-path>/home/claude/forest/trees/meta/todo.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>À faire</title>   </frontmatter> <mainmatter/> <backmatter><contributions/> <context/> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1647</anchor> <taxon>Théorème</taxon> <addr>cs-0022</addr><route>cs-0022.xml</route> <source-path>/home/claude/forest/trees/cs-0022.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>     </frontmatter> <mainmatter><p>Les faisceaux quasi-cohérents sur un schéma <tex>X</tex> forment une <link href="cs-001T.xml" type="local" addr="cs-001T" title="Catégorie abélienne">catégorie abélienne</link>.</p><p>Si de plus <tex>X</tex> est <link href="todo.xml" type="local" addr="todo" title="À faire">noethérien</link>, les faisceaux cohérents aussi.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1648</anchor> <taxon>Théorème</taxon> <addr>cs-001N</addr><route>cs-001N.xml</route> <source-path>/home/claude/forest/trees/cs-001N.tree</source-path> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Une équivalence de catégories</title>   </frontmatter> <mainmatter><p>Soit <tex>X</tex> une variété réelle lisse. Soit <tex>\pi  : E  \to  X</tex> un fibré vectoriel. Une section de <tex>\pi</tex> au dessus d'un ouvert <tex>U \subset  X</tex> est une fonction continue <tex>s: U  \to  E</tex> tel que <tex>\pi   \circ  s =  \mathrm {Id}_U</tex>.</p><ul><li>Les sections de <tex>\pi</tex> forment un faisceau localement libre de rang fini de <tex>\mathscr {O}_M</tex>-modules, <tex>  \mathscr {F}_{ \pi } </tex>.</li>
  <li>Le foncteur qui à <tex>  \pi  </tex> associe <tex>\mathscr {F}_{ \pi }</tex> est une équivalence de catégories entre fibrés vectoriels et faisceaux localement libres de rang fini sur <tex>X</tex>.</li></ul>
  
    
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1649</anchor> <taxon>Remarque</taxon>  <source-path>/home/claude/forest/trees/cs-001N.tree</source-path> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>    <parent>cs-001N</parent> </frontmatter> <mainmatter>
  <p>On a le <link href="todo.xml" type="local" addr="todo" title="À faire">même théorème</link> en remplaçant <tex>(M,  \mathscr {O}_M)</tex> par un schéma. Par contre je crois que pour un espace annelé en général ça ne marche pas.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1650</anchor> <taxon>Proposition</taxon> <addr>cs-001G</addr><route>cs-001G.xml</route> <source-path>/home/claude/forest/trees/cs-001G.tree</source-path> <date><year>2024</year> <month>2</month> <day>27</day></date>     </frontmatter> <mainmatter><p><tex>\mathcal {O} : U  \mapsto   \mathcal {O}(U)</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">faisceau</link>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1651</anchor> <taxon>Proposition</taxon> <addr>cs-001E</addr><route>cs-001E.xml</route> <source-path>/home/claude/forest/trees/cs-001E.tree</source-path> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Une base de la topologie de Zariski</title>   </frontmatter> <mainmatter><p>Pour <tex>f  \in  A</tex>, on pose <tex>D(f)</tex> le complémentaire de <tex>V((f))</tex>. Les <tex>D(f)</tex> forment une <link href="todo.xml" type="local" addr="todo" title="À faire">base</link> de la topologie de Zariski.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1652</anchor> <taxon>Remarque</taxon> <addr>cs-0013</addr><route>cs-0013.xml</route> <source-path>/home/claude/forest/trees/cs-0013.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1653</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-0013.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>    <parent>cs-0013</parent> </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1654</anchor> <taxon>Proposition</taxon> <addr>cs-000U</addr><route>cs-000U.xml</route> <source-path>/home/claude/forest/trees/cs-000U.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>   </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1655</anchor> <taxon>Corollaire</taxon> <addr>cs-000W</addr><route>cs-000W.xml</route> <source-path>/home/claude/forest/trees/cs-000W.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>   </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1656</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-000W.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1657</anchor> <taxon>Exemples</taxon> <addr>cs-000V</addr><route>cs-000V.xml</route> <source-path>/home/claude/forest/trees/cs-000V.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>   </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1658</anchor> <taxon>Corollaire</taxon> <addr>cs-0012</addr><route>cs-0012.xml</route> <source-path>/home/claude/forest/trees/cs-0012.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>   </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1659</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-0012.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>    <parent>cs-0012</parent> </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1660</anchor> <taxon>Définition</taxon> <addr>cs-000M</addr><route>cs-000M.xml</route> <source-path>/home/claude/forest/trees/cs-000M.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>   </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1661</anchor>  <addr>cs-0009</addr><route>cs-0009.xml</route> <source-path>/home/claude/forest/trees/cs-0009.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1662</anchor> <taxon>Définition</taxon> <addr>cs-000M</addr><route>cs-000M.xml</route> <source-path>/home/claude/forest/trees/cs-000M.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>   </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1663</anchor> <taxon>Définition</taxon> <addr>cs-000O</addr><route>cs-000O.xml</route> <source-path>/home/claude/forest/trees/cs-000O.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>   </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1664</anchor> <taxon>Remarque</taxon> <addr>cs-000P</addr><route>cs-000P.xml</route> <source-path>/home/claude/forest/trees/cs-000P.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>     </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1665</anchor> <taxon>Définition</taxon> <addr>cs-000N</addr><route>cs-000N.xml</route> <source-path>/home/claude/forest/trees/cs-000N.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1666</anchor> <taxon>Exemples</taxon> <addr>cs-000Q</addr><route>cs-000Q.xml</route> <source-path>/home/claude/forest/trees/cs-000Q.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>   </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1667</anchor> <taxon>Lemme</taxon> <addr>cs-000R</addr><route>cs-000R.xml</route> <source-path>/home/claude/forest/trees/cs-000R.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>   </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1668</anchor> <taxon>Définition</taxon> <addr>cs-000S</addr><route>cs-000S.xml</route> <source-path>/home/claude/forest/trees/cs-000S.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>   </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1669</anchor> <taxon>Exemple</taxon> <addr>cs-000T</addr><route>cs-000T.xml</route> <source-path>/home/claude/forest/trees/cs-000T.tree</source-path> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>   </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1670</anchor> <taxon>Définition</taxon> <addr>cs-000X</addr><route>cs-000X.xml</route> <source-path>/home/claude/forest/trees/cs-000X.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>   </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1671</anchor> <taxon>Définition</taxon> <addr>cs-000Y</addr><route>cs-000Y.xml</route> <source-path>/home/claude/forest/trees/cs-000Y.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>   </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1672</anchor> <taxon>Définition</taxon> <addr>cs-000Z</addr><route>cs-000Z.xml</route> <source-path>/home/claude/forest/trees/cs-000Z.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>   </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1673</anchor> <taxon>Proposition</taxon> <addr>cs-000U</addr><route>cs-000U.xml</route> <source-path>/home/claude/forest/trees/cs-000U.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>   </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1674</anchor> <taxon>Corollaire</taxon> <addr>cs-000W</addr><route>cs-000W.xml</route> <source-path>/home/claude/forest/trees/cs-000W.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>   </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1675</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-000W.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1676</anchor> <taxon>Exemples</taxon> <addr>cs-000V</addr><route>cs-000V.xml</route> <source-path>/home/claude/forest/trees/cs-000V.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title/>   </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1677</anchor> <taxon>Proposition</taxon> <addr>cs-0010</addr><route>cs-0010.xml</route> <source-path>/home/claude/forest/trees/cs-0010.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>   </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \ots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \ots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \ots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \ots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1678</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-0010.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1679</anchor> <taxon>Lemme</taxon> <addr>cs-0011</addr><route>cs-0011.xml</route> <source-path>/home/claude/forest/trees/cs-0011.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1680</anchor> <taxon>Corollaire</taxon> <addr>cs-0012</addr><route>cs-0012.xml</route> <source-path>/home/claude/forest/trees/cs-0012.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>   </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1681</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-0012.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1682</anchor> <taxon>Remarque</taxon> <addr>cs-0013</addr><route>cs-0013.xml</route> <source-path>/home/claude/forest/trees/cs-0013.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1683</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-0013.tree</source-path> <date><year>2024</year> <month>2</month> <day>25</day></date>     </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1684</anchor> <taxon>Définition</taxon> <addr>cs-0014</addr><route>cs-0014.xml</route> <source-path>/home/claude/forest/trees/cs-0014.tree</source-path> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1685</anchor> <taxon>Définition</taxon> <addr>cs-0015</addr><route>cs-0015.xml</route> <source-path>/home/claude/forest/trees/cs-0015.tree</source-path> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>   </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1686</anchor> <taxon>Propriété</taxon> <addr>cs-0016</addr><route>cs-0016.xml</route> <source-path>/home/claude/forest/trees/cs-0016.tree</source-path> <date><year>2024</year> <month>2</month> <day>26</day></date>     </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1687</anchor> <taxon>Exemple</taxon> <addr>cs-0003</addr><route>cs-0003.xml</route> <source-path>/home/claude/forest/trees/cs-0003.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Exemples de catégories</title>   </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1688</anchor>  <addr>cs-000E</addr><route>cs-000E.xml</route> <source-path>/home/claude/forest/trees/cs-000E.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1689</anchor> <taxon>Théorème</taxon> <addr>cs-000F</addr><route>cs-000F.xml</route> <source-path>/home/claude/forest/trees/cs-000F.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>   </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1690</anchor> <taxon>Propriété</taxon> <addr>cs-000D</addr><route>cs-000D.xml</route> <source-path>/home/claude/forest/trees/cs-000D.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1691</anchor>  <addr>cs-0007</addr><route>cs-0007.xml</route> <source-path>/home/claude/forest/trees/cs-0007.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie</title>   </frontmatter> <mainmatter><p>La topologie est l'étude des espaces les plus généraux possibles où étudier les notions de <link href="todo.xml" type="local" addr="todo" title="À faire">continuité</link> et de <link href="todo.xml" type="local" addr="todo" title="À faire">convergence</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1692</anchor>  <addr>cs-000H</addr><route>cs-000H.xml</route> <source-path>/home/claude/forest/trees/cs-000H.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Topologie de <tex>\mathbb {R}</tex></title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1693</anchor> <taxon>Définition</taxon> <addr>cs-000G</addr><route>cs-000G.xml</route> <source-path>/home/claude/forest/trees/cs-000G.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Convergence d'une suite réelle</title>   </frontmatter> <mainmatter><p>Soit <tex>(u_n)</tex> une suite réelle. On dit qu'elle converge vers <tex>\ell</tex> quand <tex display="block">\forall   \varepsilon  &gt; 0,  \exists  N  \in   \mathbb {N}, n &gt; N  \implies   \lvert  u_n -  \ell   \rvert  &lt;  \varepsilon</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1694</anchor> <taxon>Définition</taxon> <addr>cs-000I</addr><route>cs-000I.xml</route> <source-path>/home/claude/forest/trees/cs-000I.tree</source-path> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Continuité d'une fonction réelle</title>   </frontmatter> <mainmatter><p>Soit <tex>f : I  \to   \mathbb {R}</tex> une fonction réelle. On dit qu'elle est continue en <tex>a  \in   \mathbb {R}</tex> quand <tex display="block">\lim _{x \to  a} f(x) = f(a)</tex></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1695</anchor> <taxon>Propriété</taxon> <addr>cs-000J</addr><route>cs-000J.xml</route> <source-path>/home/claude/forest/trees/cs-000J.tree</source-path> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Caractérisations de la continuité</title>   </frontmatter> <mainmatter><p>Les conditions suivantes sont équivalentes :</p><ol><li><tex>f</tex> est continue en <tex>a</tex> ;</li>
  <li>Pour toute suite réelle <tex>(x_n)</tex> convergeant vers <tex>a</tex>, <tex>f(x_n)  \to  f(a)</tex> ;</li>
  <li>Pour tout <tex>\varepsilon  &gt;0</tex>, il existe <tex>\delta  &gt; 0</tex> tel que <tex display="block">\lvert  x - a \rvert  &lt;  \delta   \implies   \lvert  f(x) - f(a) \rvert  &lt;  \varepsilon</tex></li></ol></mainmatter> </tree><p>Cette dernière propriété motive la notion d'ouvert de <tex>\mathbb {R}</tex> : l'image réciproque d'un voisinage de <tex>f(a)</tex> doit être un voisinage de <tex>a</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1696</anchor> <taxon>Définition</taxon> <addr>cs-000K</addr><route>cs-000K.xml</route> <source-path>/home/claude/forest/trees/cs-000K.tree</source-path> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Ouvert de <tex>\mathbb {R}</tex></title>   </frontmatter> <mainmatter><p>Une partie <tex>A  \subset   \mathbb {R}</tex> est dite ouverte quand pour tout <tex>a \in  A</tex>, il existe <tex>\varepsilon</tex> tel que <tex display="block">\lvert   x-a \rvert  &lt;  \varepsilon   \implies  x  \in  A</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1697</anchor>  <addr>cs-000C</addr><route>cs-000C.xml</route> <source-path>/home/claude/forest/trees/cs-000C.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1698</anchor> <taxon>Propriété</taxon> <addr>cs-000D</addr><route>cs-000D.xml</route> <source-path>/home/claude/forest/trees/cs-000D.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1699</anchor>  <addr>cs-000E</addr><route>cs-000E.xml</route> <source-path>/home/claude/forest/trees/cs-000E.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1700</anchor> <taxon>Théorème</taxon> <addr>cs-000F</addr><route>cs-000F.xml</route> <source-path>/home/claude/forest/trees/cs-000F.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>   </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1701</anchor>  <addr>cs-000C</addr><route>cs-000C.xml</route> <source-path>/home/claude/forest/trees/cs-000C.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1702</anchor> <taxon>Propriété</taxon> <addr>cs-000D</addr><route>cs-000D.xml</route> <source-path>/home/claude/forest/trees/cs-000D.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1703</anchor>  <addr>cs-000E</addr><route>cs-000E.xml</route> <source-path>/home/claude/forest/trees/cs-000E.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>   </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1704</anchor> <taxon>Théorème</taxon> <addr>cs-000F</addr><route>cs-000F.xml</route> <source-path>/home/claude/forest/trees/cs-000F.tree</source-path> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>   </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1705</anchor> <taxon>Entrée journalière</taxon> <addr>2024-03-06</addr><route>2024-03-06.xml</route> <source-path>/home/claude/forest/trees/dailies/2024-03-06.tree</source-path>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Mercredi 6 mars</title>   <meta name="venue">où l'on avance sur le chemin des faisceaux cohérents.</meta></frontmatter> <mainmatter>
  <span style="display: none"><p><link href="journal.xml" type="local" addr="journal" title="Journal mathématique">journal</link></p></span>
<p>Le but - chimérique - de ces prochains jours est d'avancer vers une compréhension du théorème GAGA. Je lisl'article original de Serre, <link href="serre-gaga.xml" type="local" addr="serre-gaga" title="Géométrie algébrique et géométrie analytique">Géométrie algébrique et géométrie analytique</link> ; mais d'abord il faudrait que je sache ce qu'est un faisceau cohérent et à quoi ça sert la cohomologie des faisceaux cohérents...
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1706</anchor> <taxon>Définition</taxon> <addr>cs-001K</addr><route>cs-001K.xml</route> <source-path>/home/claude/forest/trees/cs-001K.tree</source-path> <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>  <title>Sous-ensemble analytique de <tex>\mathbb {C}^n</tex></title>   </frontmatter> <mainmatter><p><tex>U  \subset   \mathbb {C}^n</tex> est dit analytique quand pour tout <tex>x \in  U</tex>, il existe un voisinage <tex>W  \ni  x</tex> et des fonctions <tex>f_1, f_k</tex> holomorphes sur <tex>W</tex> telles que <tex display="block">U \cap  W =  \{ z \in  W  \mid  f_i(z) = 0,  \forall  i \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1707</anchor>   <source-path>/home/claude/forest/trees/dailies/2024-03-06.tree</source-path>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title><link href="2024-03-06.xml" type="local" addr="2024-03-06" title="Mercredi 6 mars">Mercredi 6 mars</link> › Les faisceaux selon Serre</title>  <parent>2024-03-06</parent> </frontmatter> <mainmatter><p>Je suis ici <link href="serre-fac.xml" type="local" addr="serre-fac" title="Faisceaux algébriques cohérents">Faisceaux algébriques cohérents</link> car les définitions sont un peu différentes de <link href="todo.xml" type="local" addr="todo" title="À faire">celles auquelles je suis habituée</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1708</anchor> <taxon>Définition</taxon>  <source-path>/home/claude/forest/trees/dailies/2024-03-06.tree</source-path>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Faisceau de groupes abéliens</title>   </frontmatter> <mainmatter><p>Un faisceau de groupes abéliens <tex>  \mathscr {F} </tex> sur un espace topologique <tex>X</tex> est la donnée d'un groupe abélien <tex>  \mathscr {F}_x </tex> pour tout <tex>x \in  X</tex> et d'une topologie sur <tex>  \bigsqcup _x  \mathscr {F}_x.</tex></p><p>On note alors <tex>\pi  : y  \in   \mathscr {F}_x  \mapsto  x</tex> et <tex>  \mathscr {F} +  \mathscr {F} =  \bigsqcup _x  \mathscr {F}_x  \times   \mathscr {F}_x </tex>.</p><p>Il faut de plus :</p><ol><li><tex>\pi</tex> est un homéomorphisme local ;</li>
    <li><tex>f  \mapsto  -f</tex> et <tex>(f, g)  \mapsto  f+g</tex> sont des applications continues respectivement de <tex>  \mathscr {F} </tex> dans <tex>  \mathscr {F} </tex> et de <tex>  \mathscr {F} +  \mathscr {F} </tex> dans <tex>  \mathscr {F} </tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1709</anchor> <taxon>Définition</taxon>  <source-path>/home/claude/forest/trees/dailies/2024-03-06.tree</source-path>  <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Section</title>   </frontmatter> <mainmatter><p>Si <tex>U  \subset  X</tex> est un ouvert, on note <tex>\Gamma (U,  \mathscr {F})</tex> les sections de <tex>  \mathscr {F} </tex> au dessus de <tex>U</tex>, i.e. les applications continues <tex>s : U  \to   \mathscr {F}</tex> telles que <tex>\pi   \circ  s =  \mathrm {Id}_U</tex>.</p></mainmatter> </tree><p>Les morphismes de restriction évidents permettent de retrouver la définition usuelle d'un faisceau ; <tex>  \mathscr {F}_x </tex> correspond bien à la limite inductive des <tex>  \Gamma (U,  \mathscr {F}) </tex> sur les voisinages de <tex>x</tex> : c'est montré dans la section §1.3 de FAC.</p></mainmatter> </tree><p>Il y a un parallèle visible dans cette définition avec les fibrés vectoriels a.k.a les faisceaux localement libres de rang fini :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1710</anchor> <taxon>Définition</taxon> <addr>cs-001M</addr><route>cs-001M.xml</route> <source-path>/home/claude/forest/trees/cs-001M.tree</source-path> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Fibré vectoriel</title>   </frontmatter> <mainmatter><p>Un fibré vectoriel (réel) sur un espace topologique <tex>X</tex> est la donnée :</p><ul><li>d'un espace topologique <tex>E</tex> dit espace total,</li>
  <li>d'une application continue et surjective <tex>\pi  : E  \to  X</tex>,</li></ul><p>tel que <tex>\pi ^{-1}(x)</tex> a une structure d'espace vectoriel de dimension finie pour tout <tex>x \in  X</tex>, et que localement <tex>E</tex> ressemble au fibré trivial, i.e. pour tout <tex>x \in  X</tex> on a un voisinage <tex>U \ni  x</tex>, <tex>k  \in   \mathbb {N}</tex> et un homéomorphisme <tex display="block">\varphi  : U  \times   \mathbb {R}^k  \to   \pi ^{-1}(U)</tex> tel que <tex>\forall   \tilde {x}  \in  U</tex>:</p><ul><li><tex>\pi   \circ   \varphi ( \tilde {x}, v) = \tilde {x}</tex>, </li>
  <li><tex>\varphi ( \tilde {x}, -)</tex> est un isomorphisme entre <tex>\mathbb {R}</tex> et <tex>\pi ^{-1}( \{ \tilde {x} \} )</tex>.</li></ul></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1711</anchor> <taxon>Théorème</taxon> <addr>cs-001N</addr><route>cs-001N.xml</route> <source-path>/home/claude/forest/trees/cs-001N.tree</source-path> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>  <title>Une équivalence de catégories</title>   </frontmatter> <mainmatter><p>Soit <tex>X</tex> une variété réelle lisse. Soit <tex>\pi  : E  \to  X</tex> un fibré vectoriel. Une section de <tex>\pi</tex> au dessus d'un ouvert <tex>U \subset  X</tex> est une fonction continue <tex>s: U  \to  E</tex> tel que <tex>\pi   \circ  s =  \mathrm {Id}_U</tex>.</p><ul><li>Les sections de <tex>\pi</tex> forment un faisceau localement libre de rang fini de <tex>\mathscr {O}_M</tex>-modules, <tex>  \mathscr {F}_{ \pi } </tex>.</li>
  <li>Le foncteur qui à <tex>  \pi  </tex> associe <tex>\mathscr {F}_{ \pi }</tex> est une équivalence de catégories entre fibrés vectoriels et faisceaux localement libres de rang fini sur <tex>X</tex>.</li></ul>
  
    
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1712</anchor> <taxon>Remarque</taxon>  <source-path>/home/claude/forest/trees/cs-001N.tree</source-path> <date href="2024-03-07.xml"><year>2024</year> <month>3</month> <day>7</day></date>     </frontmatter> <mainmatter>
  <p>On a le <link href="todo.xml" type="local" addr="todo" title="À faire">même théorème</link> en remplaçant <tex>(M,  \mathscr {O}_M)</tex> par un schéma. Par contre je crois que pour un espace annelé en général ça ne marche pas.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><p>C'est ici qu'interviennent les faisceaux quasi-cohérents et cohérents : on voudrait avoir une <link href="cs-001T.xml" type="local" addr="cs-001T" title="Catégorie abélienne">catégorie abélienne</link> pour utiliser la machinerie de l'algèbre homologique.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1713</anchor> <taxon>Exemple</taxon> <addr>cs-001S</addr><route>cs-001S.xml</route> <source-path>/home/claude/forest/trees/cs-001S.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title>Les fibrés vectoriels ne forment pas une catégorie abélienne</title>   </frontmatter> <mainmatter><p>Considérons <tex>\pi  :  \mathbb {R}  \times   \mathbb {R}  \to   \mathbb {R}</tex> le fibré de droites trivial. Considérons le morphisme <tex>f :  \mathbb {R}  \times   \mathbb {R}  \to   \mathbb {R}  \times   \mathbb {R}</tex> qui à <tex>(t, v)</tex> associe <tex>(t, tv)</tex>. Le noyau de ce morphisme n'est pas un fibré vectoriel : en <tex>t = 0</tex> il serait de rang 1, et partout ailleurs de rang nul.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1714</anchor> <taxon>Définition</taxon> <addr>cs-001Y</addr><route>cs-001Y.xml</route> <source-path>/home/claude/forest/trees/cs-001Y.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title>Faisceau quasi-cohérents</title>   </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1715</anchor> <taxon>Définition</taxon> <addr>cs-001Z</addr><route>cs-001Z.xml</route> <source-path>/home/claude/forest/trees/cs-001Z.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title>Faisceau associé à un module</title>   </frontmatter> <mainmatter><p>Soit <tex>A</tex> un anneau et <tex>M</tex> un <tex>A</tex>-module. <tex>\tilde {M}</tex>, le faisceau associé à <tex>M</tex> sur <tex>\mathrm {Spec  \,  A}</tex> est défini comme suit :</p><ul><li>Pour tout idéal premier <tex>P</tex> de <tex>A</tex>, <tex>M_P</tex> est la localisation de <tex>M</tex> en <tex>P</tex>.</li>
  <li>Pour tout ouvert <tex>U</tex> de <tex>\mathrm {Spec  \,  A}</tex>, on pose le groupe <tex display="block">\tilde {M}(U) :=  \left \{   s : U  \to   \bigsqcup _{P  \in  U} M_{P} { \,   \Huge  |  \, }  \begin {matrix}  \forall  P  \in  U, s(P)  \in  M_{P}  \\   \forall  P  \in  U,  \exists  (m,f)  \in  M  \times  A,  \text { sur un voisinage de }P, s= \frac {m}{f}    \end {matrix}  \right \}</tex></li>
  <li>On fait de <tex>\tilde {M}</tex> un faisceau avec les morphismes de restriction.</li></ul><p><tex>M</tex> est un <tex>\mathcal {O}_{ \mathrm {Spec}  \,  A}</tex>-module.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1716</anchor> <taxon>Remarque</taxon>  <source-path>/home/claude/forest/trees/cs-001Z.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>     </frontmatter> <mainmatter><p>Cette définition est totalement parallèle à <link href="cs-001F.xml" type="local" addr="cs-001F" title="{O}_{{Spec}  A}">celle du faisceau structural</link> : <tex>\tilde {A} =  \mathcal {O}_{ \mathrm {Spec}  \,  A}</tex>, et les <link href="cs-0019.xml" type="local" addr="cs-0019" title="Le faisceau structural {O}_{{Spec}  A}">propriétés de base</link> se transportent avec les mêmes preuves :</p><ul><li><tex>( \tilde {M})_P  \cong  M_P</tex> ;</li>
    <li><tex>\tilde {M}(D(f))  \cong  M_f</tex> ;</li>
    <li>En particulier, <tex>\tilde {M}( \mathrm {Spec}  \,  A)  \cong   \tilde {M}</tex>/</li></ul></mainmatter> </tree></mainmatter> </tree><p>Un faisceau quasi-cohérent sur un schéma est un faisceau qui est localement un <tex>\tilde {M}</tex>, autrement dit :</p><p>Un faisceau <tex>  \mathscr {F} </tex> sur un schéma <tex>X</tex> est dit quasi-cohérent si il existe un recouvrement de <tex>X</tex> formés d'ouverts affines <tex>\left ( \mathrm {Spec}  \,  A_i \right )</tex>, tels que pour tout <tex>i</tex> il existe un <tex>A_i</tex>-module <tex>M_i</tex> tel que <tex>  \mathscr {F}_{ \mid   \mathrm {Spec}  \,  A_i} = M_i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1717</anchor> <taxon>Définition</taxon> <addr>cs-0021</addr><route>cs-0021.xml</route> <source-path>/home/claude/forest/trees/cs-0021.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title>Faisceau cohérent</title>   </frontmatter> <mainmatter><p>Un faisceau cohérent sur un schéma <tex>X</tex> est un <link href="cs-001Y.xml" type="local" addr="cs-001Y" title="Faisceau quasi-cohérents">faisceau quasi-cohérent</link> tels que les <tex>M_i</tex> de la définition soient finiment engendrés.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1718</anchor> <taxon>Exemples</taxon> <addr>cs-0020</addr><route>cs-0020.xml</route> <source-path>/home/claude/forest/trees/cs-0020.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>  <title/>   </frontmatter> <mainmatter><ul><li>Le faisceau structural de tout schéma est cohérent.</li>
  <li>Tout faisceau localement libre est un faisceau cohérent, avec <tex>M_i</tex> un module libre.</li>
  <li>En particulier, un faisceau localement libre de rang 1 (un fibré de droites, en fait) est un faisceau cohérent. On parle de faisceau inversible (mais vraiment c'est un fibré de droites).</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1719</anchor> <taxon>Théorème</taxon> <addr>cs-0022</addr><route>cs-0022.xml</route> <source-path>/home/claude/forest/trees/cs-0022.tree</source-path> <date><year>2024</year> <month>3</month> <day>8</day></date>     </frontmatter> <mainmatter><p>Les faisceaux quasi-cohérents sur un schéma <tex>X</tex> forment une <link href="cs-001T.xml" type="local" addr="cs-001T" title="Catégorie abélienne">catégorie abélienne</link>.</p><p>Si de plus <tex>X</tex> est <link href="todo.xml" type="local" addr="todo" title="À faire">noethérien</link>, les faisceaux cohérents aussi.</p></mainmatter> </tree><p>En un certain sens - que je ne comprends pas - les faisceaux cohérents (resp. quasi-cohérents) sont la catégorie abélienne &quot;minimale&quot; qui contient les fibrés vectoriels (resp. les faisceaux localement libres).</p><p>Je commence à me faire chier ; en guise de motivation je veux comprendre comment appliquer GAGA pour trouver Chow entre autres trucs sympas. D'où :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1720</anchor>  <addr>cs-001L</addr><route>cs-001L.xml</route> <source-path>/home/claude/forest/trees/cs-001L.tree</source-path> <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>  <title>Théorème de Chow</title>   </frontmatter> <mainmatter><p>Soit <tex> X  \subset   \mathbb {P}^n </tex> une sous-variété analytique fermée. Alors <tex> X </tex> est en fait une variété algébrique.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1721</anchor> <taxon>Preuve</taxon>  <source-path>/home/claude/forest/trees/cs-001L.tree</source-path> <date href="2024-03-06.xml"><year>2024</year> <month>3</month> <day>6</day></date>     </frontmatter> <mainmatter><p>Le faisceau des fonctions holomorphes sur <tex>X</tex> est cohérent ; c'est le théorème d'Oka. Donc si on l'étend en <tex>  \tilde { \mathscr {H}} </tex>sur tout <tex>  \mathbb {P}^n </tex> par des zéros (i.e. pour <tex>x  \not \in  X,  \mathscr {F}_x =  \{ 0 \}  </tex>) il est encore cohérent sur <tex>  \mathbb {P}^n </tex>.</p><p>D'après GAGA, il existe un faisceau algébrique cohérent <tex>\mathscr {F}</tex> sur <tex>  \mathbb {P}^n </tex> tel que <tex>  \mathscr {F}^{ \mathrm {an}} </tex> soit isomorphe à <tex>\tilde { \mathscr {H}}</tex>.</p><p>Comme <tex>  \mathscr {F} </tex> et <tex>\mathscr {F}^{ \mathrm {an}}</tex> ont même support, et que le support de <tex>\mathscr {F}^{ \mathrm {an}}</tex> est par définition <tex>X</tex>, <tex>X</tex> est le support du faisceau algébrique cohérent <tex>  \mathscr {F} </tex> et donc fermé pour la topologie de Zariski, i.e. une sous-variété algébrique de <tex>\mathbb {P}^n</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>
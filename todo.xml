<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1226</anchor>  <taxon>Meta</taxon> <addr>todo</addr>  <route>todo.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>À faire</title>  </frontmatter> <mainmatter/> <backmatter><contributions/> <context/> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1227</anchor>  <taxon>Proposition</taxon> <addr>cs-001G</addr>  <route>cs-001G.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>    </frontmatter> <mainmatter><p><tex>\mathcal {O} : U  \mapsto   \mathcal {O}(U)</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">faisceau</link>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1228</anchor>  <taxon>Proposition</taxon> <addr>cs-001E</addr>  <route>cs-001E.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date>  <title>Une base de la topologie de Zariski</title>  </frontmatter> <mainmatter><p>Pour <tex>f  \in  A</tex>, on pose <tex>D(f)</tex> le complémentaire de <tex>V((f))</tex>. Les <tex>D(f)</tex> forment une <link href="todo.xml" type="local" addr="todo" title="À faire">base</link> de la topologie de Zariski.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1229</anchor>  <taxon>Remarque</taxon> <addr>cs-0013</addr>  <route>cs-0013.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1230</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>   <parent>cs-0013</parent> </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1231</anchor>  <taxon>Proposition</taxon> <addr>cs-000U</addr>  <route>cs-000U.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>  </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1232</anchor>  <taxon>Corollaire</taxon> <addr>cs-000W</addr>  <route>cs-000W.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>  </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1233</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1234</anchor>  <taxon>Exemples</taxon> <addr>cs-000V</addr>  <route>cs-000V.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title/>  </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1235</anchor>  <taxon>Corollaire</taxon> <addr>cs-0012</addr>  <route>cs-0012.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>  </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1236</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>   <parent>cs-0012</parent> </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1237</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1238</anchor>   <addr>cs-0009</addr>  <route>cs-0009.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Algèbre commutative</title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1239</anchor>  <taxon>Définition</taxon> <addr>cs-000M</addr>  <route>cs-000M.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Anneau</title>  </frontmatter> <mainmatter><p>Un anneau <tex>A</tex> est un <link href="todo.xml" type="local" addr="todo" title="À faire">ensemble</link> muni de deux lois <tex>+</tex> et <tex>\cdot</tex> telles que</p><ol><li><tex>(A, +)</tex> soit un groupe abélien,</li>
  <li><tex>(A,  \cdot )</tex> soit un monoïde,</li>
  <li><tex>\cdot</tex> soit distributive par rapport à <tex>+</tex>.</li></ol></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1240</anchor>  <taxon>Définition</taxon> <addr>cs-000O</addr>  <route>cs-000O.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Morphisme d'anneaux</title>  </frontmatter> <mainmatter><p>Un morphisme <tex>\varphi</tex> entre deux anneaux <tex>A</tex> et <tex>B</tex> est une application telle que :</p><ol><li><tex>\varphi (x+y) =  \varphi (x)+  \varphi (y)</tex>,</li>
  <li><tex>\varphi (xy) =  \varphi (x) \varphi (y)</tex>,</li>
  <li><tex>\varphi (1_A) =  \varphi (1_B)</tex>.</li></ol>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1241</anchor>  <taxon>Remarque</taxon> <addr>cs-000P</addr>  <route>cs-000P.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>    </frontmatter> <mainmatter><p>La dernière propriété n'est pas redondante avec la deuxième : par exemple, <tex>\varphi  :  \Z   \to   \Z ^2</tex> qui à <tex>k</tex> associe <tex>(k, 0)</tex> satisfait les deux premières propriétés mais pas la troisième.</p></mainmatter> </tree>
</mainmatter> </tree><p>Les anneaux forment ainsi une catégorie <tex>\mathsf {Ring}</tex>.</p><p>Dans la suite, on fixe <tex>A</tex> un anneau commutatif. Les anneaux commutatifs forment une <link href="todo.xml" type="local" addr="todo" title="À faire">sous-catégorie pleine</link> de celle des anneaux, notée <tex>\mathsf {CRing}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1242</anchor>  <taxon>Définition</taxon> <addr>cs-000N</addr>  <route>cs-000N.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Idéal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> de <tex>A</tex> est un sous-groupe de <tex>(A, +)</tex> tel que pour tout <tex>(a, i)  \in  A  \times  I</tex>, on a <tex>ai  \in  I</tex>.</p>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1243</anchor>  <taxon>Exemples</taxon> <addr>cs-000Q</addr>  <route>cs-000Q.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title/>  </frontmatter> <mainmatter><ul><li><tex>n \Z</tex> est un idéal de <tex>\Z</tex>.</li>
  <li>Si <tex>\varphi</tex> est un morphisme, <tex>\mathrm {ker}  \,   \varphi</tex> est un idéal.</li></ul></mainmatter> </tree>
</mainmatter> </tree><p>Les idéaux sont le pendant dans un anneau des sous-groupes normaux dans un groupe : ce sont les parties par lesquelles on peut quotienter.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1244</anchor>  <taxon>Lemme</taxon> <addr>cs-000R</addr>  <route>cs-000R.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Intersection d'idéaux</title>  </frontmatter> <mainmatter><p>Soit <tex>(I_i)</tex> une famille d'idéaux de <tex>A</tex>. Alors <tex>\bigcap  I_i</tex> est aussi un idéal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1245</anchor>  <taxon>Définition</taxon> <addr>cs-000S</addr>  <route>cs-000S.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal engendré</title>  </frontmatter> <mainmatter><p>Soit <tex>S</tex> une partie de <tex>A</tex>. On note <tex>(S)</tex> l'idéal minimal pour l'inclusion contenant <tex>S</tex> : autrement dit, <tex display="block">(S) =  \bigcap _{I  \text { idéal }   \supset   \,  S} I</tex></p><p>C'est bien un idéal d'après <link href="cs-000R.xml" type="local" addr="cs-000R" title="Intersection d'idéaux">le lemme 000R</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1246</anchor>  <taxon>Exemple</taxon> <addr>cs-000T</addr>  <route>cs-000T.xml</route> <date><year>2024</year> <month>2</month> <day>24</day></date>  <title>Idéal principal engendré par <tex>x</tex></title>  </frontmatter> <mainmatter><p>Soit <tex>x \in  A</tex>. L'idéal engendré par <tex>\{ x \}</tex>, noté <tex>(x)</tex>, est l'idéal formé par les éléments de la forme <tex>ax</tex> pour <tex>a  \in  A</tex>.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1247</anchor>  <taxon>Définition</taxon> <addr>cs-000X</addr>  <route>cs-000X.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Opérations sur les idéaux</title>  </frontmatter> <mainmatter><p>Soient <tex>I</tex> et <tex>J</tex> deux idéaux.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1248</anchor>  <taxon>Définition</taxon> <addr>cs-000Y</addr>  <route>cs-000Y.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Somme d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>I+J</tex> l'idéal engendré par <tex>I  \cup  J</tex> : il est formé des sommes d'éléments de <tex>I</tex> et <tex>J</tex>.
<tex display="block">I+ J =  \{ i+j | (i, j)  \in  I  \times  J  \}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1249</anchor>  <taxon>Définition</taxon> <addr>cs-000Z</addr>  <route>cs-000Z.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Produit d'idéaux</title>  </frontmatter> <mainmatter><p>On note <tex>IJ</tex> l'idéal engendré par les produits d'éléments de <tex>I</tex> et <tex>J</tex> : <tex display="block">IJ =  \left (  \{ ij | (i, j)  \in  I  \times  J  \}   \right )</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1250</anchor>  <taxon>Proposition</taxon> <addr>cs-000U</addr>  <route>cs-000U.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Anneau quotient</title>  </frontmatter> <mainmatter><p>Soit <tex>I</tex> un idéal de <tex>A</tex>. Le groupe quotient <tex>A/I</tex> admet une unique structure d'anneau compatible avec la projection. De plus, cet anneau satisfait une <link href="todo.xml" type="local" addr="todo" title="À faire">propriété universelle</link> :</p><p>Tout morphisme d'anneau <tex>\varphi  : A  \to  B</tex> avec <tex>I  \subset   \mathrm {ker}  \,   \varphi</tex> se factorise par <tex>A/I</tex>, i.e. on a le diagramme</p>
 <embedded-tex hash="9daa6567807ac75f152034b4205202e7"><embedded-tex-preamble>
   \usepackage {preamble}
   \usepackage {quiver}
 </embedded-tex-preamble> <embedded-tex-body>
  \begin {tikzcd}[sep=3em]
A  \arrow [r, &quot; \varphi &quot;]  \arrow [d, &quot; \pi &quot;, two heads] &amp; B  \\ 
A/I  \arrow [ru, &quot; \tilde { \varphi }&quot;']                 &amp;  
 \end {tikzcd}
</embedded-tex-body></embedded-tex>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1251</anchor>  <taxon>Corollaire</taxon> <addr>cs-000W</addr>  <route>cs-000W.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème d'isomorphisme</title>  </frontmatter> <mainmatter><p>Soit <tex>\varphi : A  \to  B</tex> un morphisme. Alors on a un isomorphisme <tex display="block">A/  \mathrm {ker}  \,   \varphi   \cong   \mathrm {im}  \,   \varphi</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1252</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>Le morphisme <tex>\tilde { \varphi }</tex> donné par la propriété universelle du quotient est en fait injectif, donc un isomorphisme sur son image.</p>
</mainmatter> </tree>
  
</mainmatter> </tree>



<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1253</anchor>  <taxon>Exemples</taxon> <addr>cs-000V</addr>  <route>cs-000V.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title/>  </frontmatter> <mainmatter><ul><li>L'anneau <tex>\mathbb {Z}  / n \mathbb {Z}</tex> est le quotient de <tex>\mathbb {Z}</tex> par l'idéal <tex>(n)</tex>, dont les éléments sont les restes de la division par <tex>n</tex>.</li>
  <li>L'anneau <tex>\mathbb {R} [X]/(X^2+1)</tex> est isomorphe à <tex>\mathbb {C}</tex> via l'évaluation en <tex>i</tex>.</li>
  <li>L'anneau <tex>\mathbb {Z} [X]/(X^2-2)</tex> est isomorphe à <tex>\mathbb {Z} [ \sqrt {2}]</tex> via l'évaluation en <tex>\sqrt {2}</tex>.</li></ul></mainmatter> </tree>
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1254</anchor>  <taxon>Proposition</taxon> <addr>cs-0010</addr>  <route>cs-0010.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois généralisé</title>  </frontmatter> <mainmatter><p>Soit <tex>I_{1},  \cdots ,I_{n}</tex>  des idéaux tels que pour tous <tex>i \neq  j</tex>, <tex>I_{i} + I_{j} = A</tex>. Alors le morphisme  <tex display="block">\begin {align*}  \varphi _{n} : A &amp; \to  A/I_{1}  \times   \cdots   \times  A/I_{n}  \\  x &amp; \mapsto  (x  \text { mod } I_{1},  \cdots , x  \text { mod } I_{n})  \end {align*}</tex>
est surjectif de noyau <tex>I_{1}  \cap   \cdots   \cap  I_{n}</tex>, et on a donc un isomorphisme : <tex display="block">A / I_{1}  \cap   \cdots   \cap  I_{n}  \cong  A/I_{1}  \times   \cdots   \times  A/I_{n}</tex></p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1255</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1256</anchor>  <taxon>Lemme</taxon> <addr>cs-0011</addr>  <route>cs-0011.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>Si <tex>I_1 + I_2 = A</tex> et <tex>I_1 + I_3 = A</tex>, alors <tex>I_1 + I_2 I_3 = A</tex>.</p></mainmatter> </tree>

<p>Pour <tex>n=1</tex>, le théorème est trivial (<tex>\varphi _{1}</tex> est la réduction modulo <tex>I_{1}</tex> qui est bien sur surjective de noyau <tex>I_{1}</tex>).</p>

<p>Pour <tex>n=2</tex>, le noyau est évidemment <tex>I_{1}  \cap  I_{2}</tex> ; de plus par hypothèse il existe <tex>a_1  \in  I_{1}</tex> et <tex>a_{2}  \in  I_{2}</tex> tels que <tex>a_{1}+a_{2}=1</tex>. Alors <tex>\varphi _{2}(a_1) = (0,1)</tex>  et <tex>\varphi _{2}(a_{2})=(1,0)</tex>.  Donc étant donné <tex>( \bar {x},  \bar {y})  \in  A/I_{1}  \times  A/I_{2}</tex>, on a un antécédent <tex>xa_1 + ya_2  \in  A</tex>. D'où <tex>\varphi _{2}</tex> surjectif et l'isomorphisme suit par théorème d'isomorphisme.</p>

<p>Soit <tex>n  \in   \mathbb {N}^{*}</tex> et <tex>I_{1},  \cdots , I_{n+1}</tex> des idéaux premiers deux à deux de <tex>A</tex>. Supposons <tex>\varphi _{n}</tex>  surjectif et montrons <tex>\varphi _{n+1}</tex> surjectif. Comme <tex>I_{n+1}</tex> est premier avec tous les <tex>I_{i}</tex>, il est aussi premier avec <tex>\bigcap  I_{i}</tex> et on peut appliquer le théorème : on obtient que le morphisme qui envoie <tex>x</tex> sur  <tex>(x  \text { mod } I_{1}  \cap   \cdots   \cap  I_{n}, x  \text { mod } I_{n+1})</tex> est surjectif ; en appliquant <tex>\varphi _{n}</tex> sur la première composante, on retrouve <tex>\varphi _{n+1}</tex> qui est bien surjectif. Le noyau et l'isomorphisme sont faciles comme précédemment.</p>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1257</anchor>  <taxon>Corollaire</taxon> <addr>cs-0012</addr>  <route>cs-0012.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>  <title>Théorème chinois</title>  </frontmatter> <mainmatter><p>Soit <tex>n</tex> et <tex>m</tex> deux entiers premiers entre eux. Alors <tex>\mathbb {Z}  /nm \mathbb {Z}   \cong   \mathbb {Z}  /n \mathbb {Z}   \times   \mathbb {Z}  /m \mathbb {Z}</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1258</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p>D'après le <link href="todo.xml" type="local" addr="todo" title="À faire">théorème de Bézout</link>, on a bien <tex>n \mathbb {Z}  + m \mathbb {Z}  =  \mathbb {Z}</tex> donc le théorème s'applique.</p>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1259</anchor>  <taxon>Remarque</taxon> <addr>cs-0013</addr>  <route>cs-0013.xml</route> <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter><p>En fait, dans les conditions du théorème, l'intersection <tex>I_1  \cap   \cdots   \cap  I_n</tex> est exactement le produit <tex>I_1 I_2  \cdots  I_n</tex>.</p>
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>1260</anchor>  <taxon>Preuve</taxon>    <date href="2024-02-25.xml"><year>2024</year> <month>2</month> <day>25</day></date>    </frontmatter> <mainmatter>
  <p><link href="todo.xml" type="local" addr="todo" title="À faire">À faire</link></p>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1261</anchor>  <taxon>Définition</taxon> <addr>cs-0014</addr>  <route>cs-0014.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal premier</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit premier quand <tex>I \neq  A</tex> et <tex display="block">xy  \in  A  \implies  x  \in  A  \text { ou } y  \in  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1262</anchor>  <taxon>Définition</taxon> <addr>cs-0015</addr>  <route>cs-0015.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>  <title>Idéal maximal</title>  </frontmatter> <mainmatter><p>Un idéal <tex>I</tex> est dit maximal quand pour tout idéal <tex>J</tex>, <tex display="block">I  \subset  J  \subset  A  \implies  I = J  \text { ou } J = A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1263</anchor>  <taxon>Propriété</taxon> <addr>cs-0016</addr>  <route>cs-0016.xml</route> <date><year>2024</year> <month>2</month> <day>26</day></date>    </frontmatter> <mainmatter><ol><li><tex>I</tex> est premier si et seulement si <tex>A/I</tex> est intègre.</li>
  <li><tex>I</tex> est maximal si et seulement si <tex>A/I</tex> est un corps.</li>
  <li>Un idéal maximal est premier.</li></ol></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1264</anchor>  <taxon>Exemple</taxon> <addr>cs-0003</addr>  <route>cs-0003.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Exemples de catégories</title>  </frontmatter> <mainmatter>
  <table>
  
  <tr>
    
  <th><p>Catégorie</p></th>

    
  <th><p>Objets</p></th>

    
  <th><p>Morphismes</p></th>

    
  <th><p>Composition</p></th>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Set}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">ensembles</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Grp}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes de groupes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Ring}</tex></p></td>

    
  <td><p><link href="cs-000M.xml" type="local" addr="cs-000M" title="Anneau">anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">morphismes d'anneaux</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathscr {C}_M</tex></p></td>

    
  <td><p>un seul objet <tex>\cdot</tex></p></td>

    
  <td><p>éléments d'un monoïde <tex>M</tex></p></td>

    
  <td><p>multiplication</p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>h \mathsf {Top}</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">espaces topologiques</link></p></td>

    
  <td><p>classes d'<link href="todo.xml" type="local" addr="todo" title="À faire">homotopie</link> des <link href="todo.xml" type="local" addr="todo" title="À faire">fonctions continues</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>\mathsf {Vect}_k</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire"><tex>k</tex>-espaces vectoriels</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>k</tex>-linéaires</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>

  
  <tr>
    
  <td><p><tex>G \mathsf {Set}</tex></p></td>

    
  <td><p>ensemble muni d'une <link href="todo.xml" type="local" addr="todo" title="À faire">action</link> d'un groupe <tex>G</tex></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">applications <tex>G</tex>-équivariantes</link></p></td>

    
  <td><p><link href="todo.xml" type="local" addr="todo" title="À faire">composition de fonctions</link></p></td>

  </tr>
  
</table>
<p>et bien d'autres...</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1265</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1266</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1267</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1268</anchor>   <addr>cs-0007</addr>  <route>cs-0007.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie</title>  </frontmatter> <mainmatter><p>La topologie est l'étude des espaces les plus généraux possibles où étudier les notions de <link href="todo.xml" type="local" addr="todo" title="À faire">continuité</link> et de <link href="todo.xml" type="local" addr="todo" title="À faire">convergence</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1269</anchor>   <addr>cs-000H</addr>  <route>cs-000H.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Topologie de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1270</anchor>  <taxon>Définition</taxon> <addr>cs-000G</addr>  <route>cs-000G.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Convergence d'une suite réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>(u_n)</tex> une suite réelle. On dit qu'elle converge vers <tex>\ell</tex> quand <tex display="block">\forall   \varepsilon  &gt; 0,  \exists  N  \in   \mathbb {N}, n &gt; N  \implies   \lvert  u_n -  \ell   \rvert  &lt;  \varepsilon</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1271</anchor>  <taxon>Définition</taxon> <addr>cs-000I</addr>  <route>cs-000I.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Continuité d'une fonction réelle</title>  </frontmatter> <mainmatter><p>Soit <tex>f : I  \to   \mathbb {R}</tex> une fonction réelle. On dit qu'elle est continue en <tex>a  \in   \mathbb {R}</tex> quand <tex display="block">\lim _{x \to  a} f(x) = f(a)</tex></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1272</anchor>  <taxon>Propriété</taxon> <addr>cs-000J</addr>  <route>cs-000J.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Caractérisations de la continuité</title>  </frontmatter> <mainmatter><p>Les conditions suivantes sont équivalentes :</p><ol><li><tex>f</tex> est continue en <tex>a</tex> ;</li>
  <li>Pour toute suite réelle <tex>(x_n)</tex> convergeant vers <tex>a</tex>, <tex>f(x_n)  \to  f(a)</tex> ;</li>
  <li>Pour tout <tex>\varepsilon  &gt;0</tex>, il existe <tex>\delta  &gt; 0</tex> tel que <tex display="block">\lvert  x - a \rvert  &lt;  \delta   \implies   \lvert  f(x) - f(a) \rvert  &lt;  \varepsilon</tex></li></ol></mainmatter> </tree><p>Cette dernière propriété motive la notion d'ouvert de <tex>\mathbb {R}</tex> : l'image réciproque d'un voisinage de <tex>f(a)</tex> doit être un voisinage de <tex>a</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1273</anchor>  <taxon>Définition</taxon> <addr>cs-000K</addr>  <route>cs-000K.xml</route> <date><year>2024</year> <month>2</month> <day>22</day></date>  <title>Ouvert de <tex>\mathbb {R}</tex></title>  </frontmatter> <mainmatter><p>Une partie <tex>A  \subset   \mathbb {R}</tex> est dite ouverte quand pour tout <tex>a \in  A</tex>, il existe <tex>\varepsilon</tex> tel que <tex display="block">\lvert   x-a \rvert  &lt;  \varepsilon   \implies  x  \in  A</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1274</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1275</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1276</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1277</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>1278</anchor>   <addr>cs-000C</addr>  <route>cs-000C.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date> <authors><author><link href="claude.xml" type="local" claude="addr">Claude</link></author> </authors> <title>Topologie de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>On se place dans l'<link href="todo.xml" type="local" addr="todo" title="À faire">espace vectoriel</link> <tex>\mathbb {R}^n</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1279</anchor>  <taxon>Propriété</taxon> <addr>cs-000D</addr>  <route>cs-000D.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Produit scalaire canonique de <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p><tex>\mathbb {R}^n</tex> est muni du <link href="todo.xml" type="local" addr="todo" title="À faire">produit scalaire</link> canonique donné par <tex display="block">\left &lt;  \begin {pmatrix} x_1 ,  \dots  &amp; x_n  \end {pmatrix}  \mid   \begin {pmatrix} y_1 &amp;  \dots  &amp; y_n  \end {pmatrix}  \right &gt; =  \sum _{i=1}^{n} x_i y_i</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1280</anchor>   <addr>cs-000E</addr>  <route>cs-000E.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title>Normes dans <tex>\mathbb {R}^n</tex></title>  </frontmatter> <mainmatter><p>La <link href="todo.xml" type="local" addr="todo" title="À faire">norme induite par le produit scalaire</link> est donc <tex display="block">\lVert  x  \rVert  =  \left (  \sum  x_i^2  \right )^{ \frac {1}{2}}</tex></p><p>Sur ce modèle, on peut définir les <tex>p</tex>-normes, pour <tex>p \leqslant  1</tex> un réel :</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>1281</anchor>  <taxon>Théorème</taxon> <addr>cs-000F</addr>  <route>cs-000F.xml</route> <date><year>2024</year> <month>2</month> <day>21</day></date>  <title><tex>p</tex>-normes</title>  </frontmatter> <mainmatter><p>Soit <tex>1  \leqslant  p &lt;  \infty</tex>. On définit <tex display="block">\lVert  x  \rVert _{p} =  \left (  \sum  x_{i}^p  \right )^{ \frac {1}{p}}  </tex></p><p>Il s'agit d'une norme.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>
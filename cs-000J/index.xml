<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>18</fr:day>
    </fr:date>
    <fr:uri>https://c-sarrazin.github.io/cs-000J/</fr:uri>
    <fr:display-uri>cs-000J</fr:display-uri>
    <fr:route>/cs-000J/</fr:route>
    <fr:title text="Mécanique hamiltonienne">Mécanique hamiltonienne</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>18</fr:day>
        </fr:date>
        <fr:title text="Équations de Newton et d'Hamilton">Équations de Newton et d'Hamilton</fr:title>
      </fr:frontmatter>
      <fr:mainmatter><html:p>On considère un point matériel de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> évoluant sur une variété riemannienne <fr:tex display="inline"><![CDATA[M]]></fr:tex> et soumis à une force. Pour décrire sa dynamique, on peut écrire une équation de Newton "coordinate-free" :</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000S/</fr:uri><fr:display-uri>cs-000S</fr:display-uri><fr:route>/cs-000S/</fr:route><fr:title text="Équation de Newton">Équation de Newton</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel, i.e. une fonction lisse <fr:tex display="inline"><![CDATA[V : M \to  \mathbb {R}]]></fr:tex>. L'équation de Newton sur <fr:tex display="inline"><![CDATA[M]]></fr:tex> s'écrit : <fr:tex display="block"><![CDATA[m\nabla _{\dot {x}}\dot {x} = -\mathrm {grad}_g \, V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarques</fr:taxon></fr:frontmatter><fr:mainmatter><html:ol><html:li>Quand <fr:tex display="inline"><![CDATA[M = \mathbb {R^n}]]></fr:tex> muni de la métrique canonique, on obtient ainsi l'équation de Newton bien connue <fr:tex display="block"><![CDATA[m\ddot {x} = -\mathrm {grad} \, V = F.]]></fr:tex></html:li>
      <html:li>Quand notre point matériel n'est soumis à aucune force (potentiel nul) on obtient l'équation pour des géodésiques sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>, qui remplacent la ligne droite dans le mouvement rectiligne uniforme.</html:li>
      <html:li>On traite ici uniquement des forces conservatives, mais on pourrait remplacer <fr:tex display="inline"><![CDATA[-\mathrm {grad}_g\, V]]></fr:tex> par un champ de vecteurs quelconque (le champ de force).</html:li></html:ol></fr:mainmatter></fr:tree>
<html:p>On obtient ainsi une équation d'ordre 2 sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>. On veut se ramener à une équation d'ordre 1 sur l'espace des phases <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>, où l'état d'un point est décrit par sa position est son moment.</html:p>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Le vecteur vitesse est un élément de <fr:tex display="inline"><![CDATA[TM]]></fr:tex>. Le moment, lui, est un élément de <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Comme <fr:tex display="inline"><![CDATA[M]]></fr:tex> est une variété riemannienne, on dispose pour passer de l'un à l'autre des isomorphismes dits musicaux <fr:tex display="block"><![CDATA[\begin {align*}\sharp  : T^*M &\to  TM \\ p &\mapsto  p^{\sharp }\end {align*} \qquad  \begin {align*}\flat  : TM &\to  T^*M \\ v &\mapsto  v^{\flat }\end {align*}]]></fr:tex>qui ne sont autres que sur chaque fibre l'isomorphisme entre un espace vectoriel et son dual qui est donné par un produit scalaire.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000U/</fr:uri><fr:display-uri>cs-000U</fr:display-uri><fr:route>/cs-000U/</fr:route><fr:title text="Hamiltonien">Hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel <fr:tex display="inline"><![CDATA[V]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[(x,p) \in  T^*M]]></fr:tex>. On note le hamiltonien associé à <fr:tex display="inline"><![CDATA[V]]></fr:tex> <fr:tex display="block"><![CDATA[H(x,p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree><html:p>Ce hamiltonien décrit l'énergie totale (mécanique) du système : énergie cinétique + énergie potentielle. On peut réécrire l'équation de Newton comme une équation de degré 1 sur l'espace des phases qui ne fait intervenir que <fr:tex display="inline"><![CDATA[H]]></fr:tex>, c'est à dire associer à <fr:tex display="inline"><![CDATA[H]]></fr:tex> un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> dont le flot sera l'évolution du système. On dispose déjà de la différentielle <fr:tex display="inline"><![CDATA[\mathrm {d}H \in  T^*T^*M]]></fr:tex> ; il nous reste à identifier canoniquement <fr:tex display="inline"><![CDATA[TT^*M]]></fr:tex> et <fr:tex display="inline"><![CDATA[T^*T^*M]]></fr:tex>. Cela est rendu possible par la forme symplectique.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000V/</fr:uri><fr:display-uri>cs-000V</fr:display-uri><fr:route>/cs-000V/</fr:route><fr:title text="Forme symplectique sur T^*M">Forme symplectique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex> la 1-forme tautologique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> : 
<fr:tex display="block"><![CDATA[\begin {align*}
\lambda  : T^*M &\to  T^*T^*M \\
(x, p) &\mapsto  p \circ  \mathrm {d}_x \pi  
\end {align*}]]></fr:tex>
On pose <fr:tex display="inline"><![CDATA[\omega  = - \mathrm {d}\lambda ]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Si <fr:tex display="inline"><![CDATA[M=\mathbb {R}^n]]></fr:tex>, on a <fr:tex display="inline"><![CDATA[T^*M = \mathbb {R}^{2n}]]></fr:tex> et la forme symplectique s'écrit <fr:tex display="block"><![CDATA[\omega  = \sum _{i=1}^n \mathrm {d}x_i \wedge  \mathrm {d}p_i]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p>Il s'agit d'une 2-forme non dégénérée : si <fr:tex display="inline"><![CDATA[X]]></fr:tex> est un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[\omega (X, Y) = 0]]></fr:tex> pour tout autre champ de vecteurs <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, alors <fr:tex display="inline"><![CDATA[X]]></fr:tex> est nul. Cette non dégénérescence garantit la bonne définition de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> comme suit.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000W/</fr:uri><fr:display-uri>cs-000W</fr:display-uri><fr:route>/cs-000W/</fr:route><fr:title text="Champ hamiltonien">Champ hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : T^*M \to  \mathbb {R}]]></fr:tex> un hamiltonien. On note <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> l'unique champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="block"><![CDATA[\omega (X_H, \cdot ) = \mathrm {d}H(\cdot ).]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000T/</fr:uri><fr:display-uri>cs-000T</fr:display-uri><fr:route>/cs-000T/</fr:route><fr:title text="Équation d'Hamilton">Équation d'Hamilton</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\gamma (t)]]></fr:tex> est une solution à l'<fr:link href="/cs-000S/" title="Équation de Newton" uri="https://c-sarrazin.github.io/cs-000S/" display-uri="cs-000S" type="local">équation de Newton</fr:link> si et seulement si <fr:tex display="inline"><![CDATA[(\gamma (t), m\dot {\gamma }(t)^\flat )]]></fr:tex> est une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>T'as cru</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : \mathbb {R}^{2n} \to  \mathbb {R}]]></fr:tex> une fonction lisse. Le champ hamiltonien associé s'écrit <fr:tex display="block"><![CDATA[X_H = \left (\frac {\partial  H}{\partial  p_i}, -\frac {\partial  H}{\partial  x_i}\right )]]></fr:tex>et donc l'équation du mouvement devient <fr:tex display="block"><![CDATA[\dot {x}_i = \frac {\partial  H}{\partial  p_i} \qquad  \dot {p}_i = -\frac {\partial  H}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>18</fr:day>
        </fr:date>
        <fr:title text="Conséquences de l'équation d'Hamilton">Conséquences de l'équation d'Hamilton</fr:title>
      </fr:frontmatter>
      <fr:mainmatter><html:p>La forme symplectique <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> donne naturellement une notion de volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000X/</fr:uri><fr:display-uri>cs-000X</fr:display-uri><fr:route>/cs-000X/</fr:route><fr:title text="Forme volume sur T^*M">Forme volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme symplectique donne sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> la forme volume <fr:tex display="inline"><![CDATA[\frac {\omega ^{\wedge  n}}{n!}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme volume ainsi obtenue est juste la forme volume standard <fr:tex display="block"><![CDATA[\mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n \wedge  \mathrm {d} p_1 \wedge  \cdots  \wedge  \mathrm {d} p_n.]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0014/</fr:uri><fr:display-uri>cs-0014</fr:display-uri><fr:route>/cs-0014/</fr:route><fr:title text="Mesure associée à une forme volume">Mesure associée à une forme volume</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[M^n]]></fr:tex> une variété lisse munie d'une <fr:tex display="inline"><![CDATA[n]]></fr:tex>-forme ne s'annulant jamais. Elle est donc orientée. Localement dans une carte orientée positivement <fr:tex display="inline"><![CDATA[(U, \phi )]]></fr:tex>, notre forme volume est de la forme <fr:tex display="block"><![CDATA[f \, \mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n]]></fr:tex>avec <fr:tex display="inline"><![CDATA[f>0]]></fr:tex>. On pose alors pour un borélien <fr:tex display="inline"><![CDATA[B]]></fr:tex> contenu dans cette carte <fr:tex display="block"><![CDATA[\mathscr {A}(B) = \int _{\phi (B)} f.]]></fr:tex>La formule de changement de variable implique que si <fr:tex display="inline"><![CDATA[B]]></fr:tex> se trouve dans l'intersection de deux cartes, l'aire de <fr:tex display="inline"><![CDATA[B]]></fr:tex> ne dépend pas de la carte choisie pour la calculer. On définit alors l'aire d'un borélien quelconque via une partition de l'unité. On obtient ainsi une mesure de Radon sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier, ce procédé appliqué à la forme volume standard sur <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex> redonne la mesure de Lebesgue (sur les boréliens).</html:p></fr:mainmatter></fr:tree>
<html:p>La forme symplectique est naturellement conservée le long d'un flot hamiltonien.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Y/</fr:uri><fr:display-uri>cs-000Y</fr:display-uri><fr:route>/cs-000Y/</fr:route><fr:title text="Un difféomorphisme hamiltonien est un symplectomorphisme">Un difféomorphisme hamiltonien est un symplectomorphisme</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H]]></fr:tex> une fonction lisse sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[\phi ^t_H]]></fr:tex> le flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Alors <fr:tex display="block"><![CDATA[(\phi ^t_H)^* \omega  = \omega .]]></fr:tex></html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Trolololol</html:p></fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><html:p>Cela donne une première conséquence, presque triviale dans notre cadre symplectique, connue sous le nom de théorème de Liouville.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Z/</fr:uri><fr:display-uri>cs-000Z</fr:display-uri><fr:route>/cs-000Z/</fr:route><fr:title text="Théorème de Liouville">Théorème de Liouville</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La mesure ainsi définie sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> est préservé par un flot hamiltonien, c'est à dire par l'évolution en temps du système mécanique.</html:p></fr:mainmatter></fr:tree><html:p>Une deuxième conséquence est qu'il est facile - du moins en théorie - d'obtenir des équations d'évolution pour des observables quelconques.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0010/</fr:uri><fr:display-uri>cs-0010</fr:display-uri><fr:route>/cs-0010/</fr:route><fr:title text="Crochet de Poisson">Crochet de Poisson</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g]]></fr:tex> deux fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On note <fr:tex display="block"><![CDATA[\{f,g\} = \omega (X_f, X_g) \in  \mathscr {C}^\infty (T^*M).]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Sur <fr:tex display="inline"><![CDATA[\mathbb {R}^{2n}]]></fr:tex>, on a <fr:tex display="block"><![CDATA[\{ f,g \} = 
    \sum _{i}^n \frac {\partial  f}{\partial  x_i} \frac {\partial  g}{\partial  p_i} - \frac {\partial  f}{\partial  p_i} \frac {\partial  g}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0012/</fr:uri><fr:display-uri>cs-0012</fr:display-uri><fr:route>/cs-0012/</fr:route><fr:title text="L'algèbre de Lie \mathscr {C}^\infty (T^*M)">L'algèbre de Lie <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex></fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f,g,h]]></fr:tex> trois fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On a :</html:p><html:ol><html:li>(linéarité)  <fr:tex display="inline"><![CDATA[\{f, g + \lambda  h\} = \{f,g\} + \lambda \{f,h\} ;]]></fr:tex></html:li>
  <html:li>(antisymétrie) <fr:tex display="inline"><![CDATA[\{f,g\}= -\{g,f\} ;]]></fr:tex></html:li>
  <html:li>(identité de Jacobi) <fr:tex display="inline"><![CDATA[ \{f, \{g,h\} \} + \{g, \{h,f\} \} + \{h, \{f,g\} \} = 0;]]></fr:tex></html:li>
  <html:li>(identité de Leibniz) <fr:tex display="inline"><![CDATA[ \{f, gh\} = \{f,g\}h + \{f,h\}g;]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\partial _t \{f,g\} = \{\partial _t f, g\} + \{f, \partial _t g\}.]]></fr:tex></html:li></html:ol><html:p>En particulier, le crochet de Poisson fait de l'algèbre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> une algèbre de Lie.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Simples vérifications.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0015/</fr:uri><fr:display-uri>cs-0015</fr:display-uri><fr:route>/cs-0015/</fr:route><fr:title text="Morphisme d'algèbres de Lie">Morphisme d'algèbres de Lie</fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g\in  \mathscr {C}^\infty (T^*M)]]></fr:tex>. Alors on a <fr:tex display="block"><![CDATA[X_{ \{f, g\} } = [X_f, X_g],]]></fr:tex>
autrement dit <fr:tex display="inline"><![CDATA[f \mapsto  X_f]]></fr:tex> est un morphisme d'algèbres de Lie entre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> et <fr:tex display="inline"><![CDATA[\mathfrak {X}(T^*M)]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Oui oui...</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0011/</fr:uri><fr:display-uri>cs-0011</fr:display-uri><fr:route>/cs-0011/</fr:route><fr:title text="Équation d'évolution pour un observable quelconque">Équation d'évolution pour un observable quelconque</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\gamma ]]></fr:tex> une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[f\in  \mathscr {C}^\infty (M)]]></fr:tex>. On a l'équation suivante : <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (f \circ  \gamma ) = \{f, H\}.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0013/</fr:uri><fr:display-uri>cs-0013</fr:display-uri><fr:route>/cs-0013/</fr:route><fr:title text="Conservation de l'énergie">Conservation de l'énergie</fr:title><fr:taxon>Corollaire</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier,  <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (H \circ  \gamma ) = \{H, H\} = 0]]></fr:tex>c'est à dire que <fr:tex display="inline"><![CDATA[H]]></fr:tex> est constante le long du flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Autrement dit, il y a conservation de l'énergie mécanique.</html:p></fr:mainmatter></fr:tree></fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>26</fr:day>
        </fr:date>
        <fr:uri>https://c-sarrazin.github.io/cs-0016/</fr:uri>
        <fr:display-uri>cs-0016</fr:display-uri>
        <fr:route>/cs-0016/</fr:route>
        <fr:title text="L'exemple du pendule sphérique">L'exemple du pendule sphérique</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>Un pendule sphérique est constitué d'un point de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> fixé à une tige de longueur 1. La position de la masse est décrite par un point <fr:tex display="inline"><![CDATA[x = (x_1, x_2, x_3) \in  S^2]]></fr:tex> la sphère unité. Sa vitesse est décrite par <fr:tex display="inline"><![CDATA[v \in  T_xS^2]]></fr:tex>, c'est à dire <fr:tex display="inline"><![CDATA[(v_1, v_2, v_3) \in  \mathbb {R}^3]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[v\cdot  x = 0]]></fr:tex>.</html:p>
        <html:p>En tant que sous-variété de <fr:tex display="inline"><![CDATA[\mathbb {R}^3]]></fr:tex>, <fr:tex display="inline"><![CDATA[S^2]]></fr:tex> est munie d'une métrique riemannienne induite. On peut donc dire que le moment de la masse est décrit par <fr:tex display="inline"><![CDATA[p = mv^\flat  \in  T^*S^2]]></fr:tex>.</html:p>
        <html:p>La seule force à laquelle est soumise la masse est la gravité. Cela donne le hamiltonien <fr:tex display="block"><![CDATA[H(x, p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + mg x_3 = \frac {1}{2m}\left (p_{\theta }^2 + \frac {p_\phi ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>en réécrivant le hamiltonien en coordonnées sphériques sur <fr:tex display="inline"><![CDATA[S^2 \setminus  \{S, N\} \cong  ] 0, \pi   [ \times  ] 0, 2\pi   []]></fr:tex>.</html:p>
        <html:p>Les équations de Hamilton sont donc <fr:tex display="block"><![CDATA[\begin {align*}
    \dot \theta  = \frac {p_\theta }{m} \qquad  \dot \phi  = \frac {p_\phi }{m\sin ^2 \theta } \\
    \dot {p}_\theta  = \frac {p_\phi  ^2 \cos  \theta }{m\sin ^3 \theta } + mg \sin  \theta  \qquad  \dot {p}_\phi  = 0
    \end {align*}]]></fr:tex></html:p>
        <html:p>De ces équations, un physicien peut tirer des équations du second ordre en <fr:tex display="inline"><![CDATA[\theta ]]></fr:tex> et <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. On remarque aussi qu'une quantité est conservée : <fr:tex display="block"><![CDATA[p_\phi  = m \sin ^2 \theta  \dot {\phi } = (x \times  mv)_3.]]></fr:tex>
    Il s'agit du moment angulaire autour de l'axe vertical. Il est conservé car le système est invariant par rotation autour de l'axe vertical. C'est une illustration du principe de Noether : à une symétrie correspond une quantité conservée. Appelons-la :<fr:tex display="block"><![CDATA[\begin {align*}J : T^*S^2 &\to  \mathbb {R} \\
    (x,p) &\mapsto  (x \times  mv)_3\end {align*}]]></fr:tex>
    <fr:tex display="inline"><![CDATA[J]]></fr:tex> a une valeur singulière en <fr:tex display="inline"><![CDATA[\mu  = 0]]></fr:tex> venant des singularités aux pôles. Pour <fr:tex display="inline"><![CDATA[\mu  \neq  0]]></fr:tex>, <fr:tex display="inline"><![CDATA[J^{-1}(\mu )]]></fr:tex> est une sous-variété de codimension 1 de <fr:tex display="inline"><![CDATA[T^*S^2]]></fr:tex> qui est invariante par le flot. En coordonnées sphériques, il s'agit simplement de <fr:tex display="inline"><![CDATA[ \{(\theta , \phi , p_\theta , p_\phi  = \mu )\} \cong  ] 0, \pi   [ \times  S^1 \times  \mathbb {R}]]></fr:tex>
    Sur cette sous-variété, la symétrie circulaire donne une action propre et libre de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex>, par translation sur la deuxième coordonnée. On considère l'espace de phase réduit <fr:tex display="block"><![CDATA[M_\mu  := J^{-1}(\mu )/S^1 \cong  ] 0, \pi   [ \times  \mathbb {R}]]></fr:tex>
    qui est encore une variété lisse, de dimension 2 cette fois. C'est l'espace des phases où on a identifié deux états qui ne diffèrent que d'une rotation axiale. Résumons la situation :
    
 
  
  <html:figure><fr:resource hash="08e4848a9957b216e9ca2170ca000550"><fr:resource-content><html:img src="/08e4848a9957b216e9ca2170ca000550.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
\begin {tikzcd}
J^{-1}(\mu ) \arrow [r, "\iota ", hook] \arrow [d, "\pi ", two heads] & T^*S^2 \\
J^{-1}(\mu )/S^1                                                  &       
\end {tikzcd}
    ]]></fr:resource-source></fr:resource></html:figure>
 

    On cherche à obtenir une forme symplectique induite sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex>, c'est à dire une 2-forme <fr:tex display="inline"><![CDATA[\omega _{\text {red}}]]></fr:tex> fermée non dégénérée telle que <fr:tex display="inline"><![CDATA[\pi ^*\omega _{\text {red}} = \iota ^*\omega ]]></fr:tex>. Ici, on voit que <fr:tex display="inline"><![CDATA[\mathrm {d}\theta  \wedge  \mathrm {d} p_\theta ]]></fr:tex> convient.
</html:p>
        <html:p>Cela suffit pour définir le crochet de Poisson et les champs hamiltoniens comme auparavant! Ici, comme le hamiltonien est invariant sous l'action de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex> (en clair, ne dépend pas de <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>), il induit sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex> le hamiltonien <fr:tex display="block"><![CDATA[H_\mu (\theta , p_\theta ) = \frac {1}{2m}\left (p_{\theta }^2 + \frac {\mu ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>
et les équations d'Hamilton associées à <fr:tex display="inline"><![CDATA[H_\mu ]]></fr:tex> décrivent la dynamique sur l'espace de phases réduit. (Dans ce cas très spécial, on retrouve simplement les équations déjà connues.)</html:p>
        <html:p>On a ainsi exploité la symétrie pour se ramener d'un système en deux (quatre) dimensions à un système à une (deux) dimensions. C'est la réduction symplectique, qu'on rencontrera en toute généralité plus tard. De plus, la réduction symplectique d'un espace de phases complet <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> peut donner une variété qui n'est plus naturellement un espace cotangent, mais qui est quand même muni d'une 2-forme fermée non dégénérée induite par la forme symplectique canonique : c'est une variété symplectique !</html:p>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://c-sarrazin.github.io/cs-000L/</fr:uri>
            <fr:display-uri>cs-000L</fr:display-uri>
            <fr:route>/cs-000L/</fr:route>
            <fr:title text="Systèmes intégrables, toriques, semi-toriques">Systèmes intégrables, toriques, semi-toriques</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>

<fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date href="/2025-12-12/"><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>12</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0003/</fr:uri><fr:display-uri>cs-0003</fr:display-uri><fr:route>/cs-0003/</fr:route><fr:taxon>Résumé</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En mécanique classique, un système physique est décrit par un hamiltonien, qui est l'énergie totale du système : c'est une fonction réelle définie sur l'espace de phases, qui est (localement) décrit par les coordonnées position et moment. Ce hamiltonien détermine les équations d'évolution du système.</html:p><html:p>En mathématiques, un espace de phase est une variété symplectique <fr:tex display="inline"><![CDATA[M]]></fr:tex> de dimension <fr:tex display="inline"><![CDATA[2n]]></fr:tex>, sur laquelle on peut considérer un champ de vecteurs hamiltonien, dont le flot modélise l'évolution du système <fr:link href="/AM78/" title="Foundations of mechanics" uri="https://c-sarrazin.github.io/AM78/" display-uri="AM78" type="local">[AM78]</fr:link> <fr:link href="/MR99/" title="Introduction to Mechanics and Symmetry : A Basic Exposition of Classical Mechanical Systems" uri="https://c-sarrazin.github.io/MR99/" display-uri="MR99" type="local">[MR99]</fr:link>. Le hamiltonien <fr:tex display="inline"><![CDATA[H = f_{1}]]></fr:tex> est constant le long d'orbites du flot (autrement dit, l'énergie totale est conservée). On dit que le hamiltonien est une intégrale première du mouvement. Quand il existe <fr:tex display="inline"><![CDATA[n-1]]></fr:tex> autres intégrales premières <fr:tex display="inline"><![CDATA[(f_2, \dots , f_n)]]></fr:tex> "indépendantes", on dit que le système est <fr:link href="/cs-0005/" title="Système intégrable" uri="https://c-sarrazin.github.io/cs-0005/" display-uri="cs-0005" type="local">intégrable</fr:link>. On appelle <fr:tex display="block"><![CDATA[F = (f_{1}, \dots , f_{n}) : M \to  \mathbb {R}^n]]></fr:tex>l'application moment du système, et on dit que ses points singuliers (ceux où la différentielle n'est pas inversible) sont les points singuliers du système.</html:p><html:p>Les systèmes intégrables ont de bonnes propriétés, ils sont en quelque sorte à l'antipode des systèmes chaotiques. En particulier, on peut décrire à l'aide du <fr:link href="/cs-0004/" title="Théorème de Liouville-Arnold" uri="https://c-sarrazin.github.io/cs-0004/" display-uri="cs-0004" type="local">théprème d'Arnold-Liouville</fr:link> <fr:link href="/Aud01/" title="Les systèmes hamiltoniens et leur intégrabilité" uri="https://c-sarrazin.github.io/Aud01/" display-uri="Aud01" type="local">[Aud01]</fr:link> les surfaces d'énergie, les fibres de l'application moment : si <fr:tex display="inline"><![CDATA[F^{-1}(c)]]></fr:tex> ne contient aucun point singulier, alors il s'agit d'une sous variété lagrangienne invariante par le flot. Si elle est de plus compacte et connexe, elle est difféomorphe à un <fr:tex display="inline"><![CDATA[n]]></fr:tex>-tore. En fait, un voisinage tubulaire de <fr:tex display="inline"><![CDATA[F^{-1}(c)]]></fr:tex> est alors symplectomorphe à <fr:tex display="inline"><![CDATA[T^{*}\mathbb {T}^n]]></fr:tex> muni de la forme de Liouville. En particulier, comme <fr:tex display="inline"><![CDATA[T^{*}\mathbb {T}^n \cong  \mathbb {R}^n \times  \mathbb {T}^n]]></fr:tex>, il existe des coordonnées lisses dites "action-angle" <fr:tex display="inline"><![CDATA[(\alpha _{1}, \dots , \alpha _{n}, \theta _{1}, ..., \theta _{n})]]></fr:tex> qui paramètrent ce voisinage de <fr:tex display="inline"><![CDATA[F^{-1}(c)]]></fr:tex>. Enfin, dans ces coordonnées action angle, <fr:tex display="inline"><![CDATA[\frac {\mathrm {d}\theta }{\mathrm {d}t}]]></fr:tex> ne dépend que de <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex>. Au final, on a dit que <fr:tex display="inline"><![CDATA[M]]></fr:tex> était feuilletée par des tores invariants sur lesquels le mouvement est un flot linéaire. On comprend donc complétement la dynamique au voisinage d'un niveau régulier.</html:p><html:p>Un cas particulier très intéressant de système intégrable est le cas des variétés toriques <fr:link href="/Can08/" title="Lectures on symplectic geometry" uri="https://c-sarrazin.github.io/Can08/" display-uri="Can08" type="local">[Can08]</fr:link>. C'est le cas si <fr:tex display="inline"><![CDATA[M]]></fr:tex> est compacte (pour simplifier) et si toutes les intégrales premières qu'on s'est données sont <fr:tex display="inline"><![CDATA[2\pi ]]></fr:tex>-périodiques : cela revient à dire que le système a une symétrie circulaire dans chaque degré de liberté. Le système est ainsi muni d'une action hamiltonienne du tore <fr:tex display="inline"><![CDATA[\mathbb {T}^n]]></fr:tex>. Dans ces cas-là, le théorème d'Atiyah-Guillemin-Sternberg affirme que :</html:p><html:ul><html:li>Les fibres de <fr:tex display="inline"><![CDATA[F]]></fr:tex> sont connexes, de telle sorte que le théorème précédent s'applique : ces fibres sont des tores ;</html:li>
  <html:li>L'image de <fr:tex display="inline"><![CDATA[F]]></fr:tex> est l'enveloppe convexe de l'image des points fixes pour l'action de <fr:tex display="inline"><![CDATA[\mathbb {T}^n]]></fr:tex>.</html:li></html:ul><html:p>Ce théorème est valable quand on a une action hamiltonienne d'un tore de toute dimension. Ici, en utilisant le fait que ce tore est de dimension maximale, on peut dire encore plus sur l'image de l'application moment : il s'agit d'un polytope <fr:tex display="inline"><![CDATA[\Delta  \subset  \mathbb {R}^n]]></fr:tex>, qui vérifie les propriétés suivantes :</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> est simple : en tout sommet se rencontrent exactement <fr:tex display="inline"><![CDATA[n]]></fr:tex> arêtes ;</html:li>
  <html:li><fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> est rationnel : pour tout sommet <fr:tex display="inline"><![CDATA[p\in  \mathbb {R}^n]]></fr:tex>, les arêtes partant de <fr:tex display="inline"><![CDATA[p]]></fr:tex> sont de la forme <fr:tex display="inline"><![CDATA[p+tu_i]]></fr:tex> avec <fr:tex display="inline"><![CDATA[u_i \in  \mathbb {Z}^n]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> est non dégénéré : en tout somment, on peut choisir comme <fr:tex display="inline"><![CDATA[(u_1, \dots , u_n)]]></fr:tex> une <fr:tex display="inline"><![CDATA[\mathbb {Z}]]></fr:tex>-base de <fr:tex display="inline"><![CDATA[\mathbb {Z}^d]]></fr:tex>.</html:li></html:ul><html:p>Un tel polytope est dit polytope de Deleuze (ou quelque chose comme ça). En fait, la donnée de ce polytope est assez pour reconstruire la variété torique avec son application moment ! C'est le théorème de Danza-Kuduro. Les variétés toriques sont donc extrêmement rigides : cela permet d'en faire une étude très complète. Mais la plupart des systèmes intégrables qui apparaissent réellement ne sont pas toriques. Dans le cas d'un système à deux degrés de liberté, c'est à dire une variété symplectique de dimension 4, une direction naturelle dans laquelle généraliser la situation précédente est de ne demander plus qu'une direction d'invariance circulaire. On arrive ainsi aux variétés semi-toriques <fr:link href="/Pal25/" title="Integrable Systems with Symmetries : Toric, Semitoric, and Beyond" uri="https://c-sarrazin.github.io/Pal25/" display-uri="Pal25" type="local">[Pal25]</fr:link>, qu'il est aussi possible de classifier, mais avec une liste d'invariants plus compliquée. Les variétés semi-toriques incluent certains exemples physiquement intéressants, comme le système des moments angulaires couplés.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000J/</fr:uri><fr:display-uri>cs-000J</fr:display-uri><fr:route>/cs-000J/</fr:route><fr:title text="Mécanique hamiltonienne">Mécanique hamiltonienne</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Équations de Newton et d'Hamilton">Équations de Newton et d'Hamilton</fr:title></fr:frontmatter><fr:mainmatter><html:p>On considère un point matériel de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> évoluant sur une variété riemannienne <fr:tex display="inline"><![CDATA[M]]></fr:tex> et soumis à une force. Pour décrire sa dynamique, on peut écrire une équation de Newton "coordinate-free" :</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000S/</fr:uri><fr:display-uri>cs-000S</fr:display-uri><fr:route>/cs-000S/</fr:route><fr:title text="Équation de Newton">Équation de Newton</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel, i.e. une fonction lisse <fr:tex display="inline"><![CDATA[V : M \to  \mathbb {R}]]></fr:tex>. L'équation de Newton sur <fr:tex display="inline"><![CDATA[M]]></fr:tex> s'écrit : <fr:tex display="block"><![CDATA[m\nabla _{\dot {x}}\dot {x} = -\mathrm {grad}_g \, V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarques</fr:taxon></fr:frontmatter><fr:mainmatter><html:ol><html:li>Quand <fr:tex display="inline"><![CDATA[M = \mathbb {R^n}]]></fr:tex> muni de la métrique canonique, on obtient ainsi l'équation de Newton bien connue <fr:tex display="block"><![CDATA[m\ddot {x} = -\mathrm {grad} \, V = F.]]></fr:tex></html:li>
      <html:li>Quand notre point matériel n'est soumis à aucune force (potentiel nul) on obtient l'équation pour des géodésiques sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>, qui remplacent la ligne droite dans le mouvement rectiligne uniforme.</html:li>
      <html:li>On traite ici uniquement des forces conservatives, mais on pourrait remplacer <fr:tex display="inline"><![CDATA[-\mathrm {grad}_g\, V]]></fr:tex> par un champ de vecteurs quelconque (le champ de force).</html:li></html:ol></fr:mainmatter></fr:tree>
<html:p>On obtient ainsi une équation d'ordre 2 sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>. On veut se ramener à une équation d'ordre 1 sur l'espace des phases <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>, où l'état d'un point est décrit par sa position est son moment.</html:p>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Le vecteur vitesse est un élément de <fr:tex display="inline"><![CDATA[TM]]></fr:tex>. Le moment, lui, est un élément de <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Comme <fr:tex display="inline"><![CDATA[M]]></fr:tex> est une variété riemannienne, on dispose pour passer de l'un à l'autre des isomorphismes dits musicaux <fr:tex display="block"><![CDATA[\begin {align*}\sharp  : T^*M &\to  TM \\ p &\mapsto  p^{\sharp }\end {align*} \qquad  \begin {align*}\flat  : TM &\to  T^*M \\ v &\mapsto  v^{\flat }\end {align*}]]></fr:tex>qui ne sont autres que sur chaque fibre l'isomorphisme entre un espace vectoriel et son dual qui est donné par un produit scalaire.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000U/</fr:uri><fr:display-uri>cs-000U</fr:display-uri><fr:route>/cs-000U/</fr:route><fr:title text="Hamiltonien">Hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[(M, g)]]></fr:tex> une variété riemannienne munie d'un potentiel <fr:tex display="inline"><![CDATA[V]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[(x,p) \in  T^*M]]></fr:tex>. On note le hamiltonien associé à <fr:tex display="inline"><![CDATA[V]]></fr:tex> <fr:tex display="block"><![CDATA[H(x,p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + V(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree><html:p>Ce hamiltonien décrit l'énergie totale (mécanique) du système : énergie cinétique + énergie potentielle. On peut réécrire l'équation de Newton comme une équation de degré 1 sur l'espace des phases qui ne fait intervenir que <fr:tex display="inline"><![CDATA[H]]></fr:tex>, c'est à dire associer à <fr:tex display="inline"><![CDATA[H]]></fr:tex> un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> dont le flot sera l'évolution du système. On dispose déjà de la différentielle <fr:tex display="inline"><![CDATA[\mathrm {d}H \in  T^*T^*M]]></fr:tex> ; il nous reste à identifier canoniquement <fr:tex display="inline"><![CDATA[TT^*M]]></fr:tex> et <fr:tex display="inline"><![CDATA[T^*T^*M]]></fr:tex>. Cela est rendu possible par la forme symplectique.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000V/</fr:uri><fr:display-uri>cs-000V</fr:display-uri><fr:route>/cs-000V/</fr:route><fr:title text="Forme symplectique sur T^*M">Forme symplectique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex> la 1-forme tautologique sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> : 
<fr:tex display="block"><![CDATA[\begin {align*}
\lambda  : T^*M &\to  T^*T^*M \\
(x, p) &\mapsto  p \circ  \mathrm {d}_x \pi  
\end {align*}]]></fr:tex>
On pose <fr:tex display="inline"><![CDATA[\omega  = - \mathrm {d}\lambda ]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Si <fr:tex display="inline"><![CDATA[M=\mathbb {R}^n]]></fr:tex>, on a <fr:tex display="inline"><![CDATA[T^*M = \mathbb {R}^{2n}]]></fr:tex> et la forme symplectique s'écrit <fr:tex display="block"><![CDATA[\omega  = \sum _{i=1}^n \mathrm {d}x_i \wedge  \mathrm {d}p_i]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p>Il s'agit d'une 2-forme non dégénérée : si <fr:tex display="inline"><![CDATA[X]]></fr:tex> est un champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[\omega (X, Y) = 0]]></fr:tex> pour tout autre champ de vecteurs <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, alors <fr:tex display="inline"><![CDATA[X]]></fr:tex> est nul. Cette non dégénérescence garantit la bonne définition de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> comme suit.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000W/</fr:uri><fr:display-uri>cs-000W</fr:display-uri><fr:route>/cs-000W/</fr:route><fr:title text="Champ hamiltonien">Champ hamiltonien</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : T^*M \to  \mathbb {R}]]></fr:tex> un hamiltonien. On note <fr:tex display="inline"><![CDATA[X_H]]></fr:tex> l'unique champ de vecteurs sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> tel que <fr:tex display="block"><![CDATA[\omega (X_H, \cdot ) = \mathrm {d}H(\cdot ).]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000T/</fr:uri><fr:display-uri>cs-000T</fr:display-uri><fr:route>/cs-000T/</fr:route><fr:title text="Équation d'Hamilton">Équation d'Hamilton</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\gamma (t)]]></fr:tex> est une solution à l'<fr:link href="/cs-000S/" title="Équation de Newton" uri="https://c-sarrazin.github.io/cs-000S/" display-uri="cs-000S" type="local">équation de Newton</fr:link> si et seulement si <fr:tex display="inline"><![CDATA[(\gamma (t), m\dot {\gamma }(t)^\flat )]]></fr:tex> est une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>T'as cru</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H : \mathbb {R}^{2n} \to  \mathbb {R}]]></fr:tex> une fonction lisse. Le champ hamiltonien associé s'écrit <fr:tex display="block"><![CDATA[X_H = \left (\frac {\partial  H}{\partial  p_i}, -\frac {\partial  H}{\partial  x_i}\right )]]></fr:tex>et donc l'équation du mouvement devient <fr:tex display="block"><![CDATA[\dot {x}_i = \frac {\partial  H}{\partial  p_i} \qquad  \dot {p}_i = -\frac {\partial  H}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Conséquences de l'équation d'Hamilton">Conséquences de l'équation d'Hamilton</fr:title></fr:frontmatter><fr:mainmatter><html:p>La forme symplectique <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> donne naturellement une notion de volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000X/</fr:uri><fr:display-uri>cs-000X</fr:display-uri><fr:route>/cs-000X/</fr:route><fr:title text="Forme volume sur T^*M">Forme volume sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex></fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme symplectique donne sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> la forme volume <fr:tex display="inline"><![CDATA[\frac {\omega ^{\wedge  n}}{n!}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La forme volume ainsi obtenue est juste la forme volume standard <fr:tex display="block"><![CDATA[\mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n \wedge  \mathrm {d} p_1 \wedge  \cdots  \wedge  \mathrm {d} p_n.]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0014/</fr:uri><fr:display-uri>cs-0014</fr:display-uri><fr:route>/cs-0014/</fr:route><fr:title text="Mesure associée à une forme volume">Mesure associée à une forme volume</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[M^n]]></fr:tex> une variété lisse munie d'une <fr:tex display="inline"><![CDATA[n]]></fr:tex>-forme ne s'annulant jamais. Elle est donc orientée. Localement dans une carte orientée positivement <fr:tex display="inline"><![CDATA[(U, \phi )]]></fr:tex>, notre forme volume est de la forme <fr:tex display="block"><![CDATA[f \, \mathrm {d} x_1 \wedge  \cdots  \wedge  \mathrm {d} x_n]]></fr:tex>avec <fr:tex display="inline"><![CDATA[f>0]]></fr:tex>. On pose alors pour un borélien <fr:tex display="inline"><![CDATA[B]]></fr:tex> contenu dans cette carte <fr:tex display="block"><![CDATA[\mathscr {A}(B) = \int _{\phi (B)} f.]]></fr:tex>La formule de changement de variable implique que si <fr:tex display="inline"><![CDATA[B]]></fr:tex> se trouve dans l'intersection de deux cartes, l'aire de <fr:tex display="inline"><![CDATA[B]]></fr:tex> ne dépend pas de la carte choisie pour la calculer. On définit alors l'aire d'un borélien quelconque via une partition de l'unité. On obtient ainsi une mesure de Radon sur <fr:tex display="inline"><![CDATA[M]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier, ce procédé appliqué à la forme volume standard sur <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex> redonne la mesure de Lebesgue (sur les boréliens).</html:p></fr:mainmatter></fr:tree>
<html:p>La forme symplectique est naturellement conservée le long d'un flot hamiltonien.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Y/</fr:uri><fr:display-uri>cs-000Y</fr:display-uri><fr:route>/cs-000Y/</fr:route><fr:title text="Un difféomorphisme hamiltonien est un symplectomorphisme">Un difféomorphisme hamiltonien est un symplectomorphisme</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[H]]></fr:tex> une fonction lisse sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[\phi ^t_H]]></fr:tex> le flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Alors <fr:tex display="block"><![CDATA[(\phi ^t_H)^* \omega  = \omega .]]></fr:tex></html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Trolololol</html:p></fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><html:p>Cela donne une première conséquence, presque triviale dans notre cadre symplectique, connue sous le nom de théorème de Liouville.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000Z/</fr:uri><fr:display-uri>cs-000Z</fr:display-uri><fr:route>/cs-000Z/</fr:route><fr:title text="Théorème de Liouville">Théorème de Liouville</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>La mesure ainsi définie sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> est préservé par un flot hamiltonien, c'est à dire par l'évolution en temps du système mécanique.</html:p></fr:mainmatter></fr:tree><html:p>Une deuxième conséquence est qu'il est facile - du moins en théorie - d'obtenir des équations d'évolution pour des observables quelconques.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0010/</fr:uri><fr:display-uri>cs-0010</fr:display-uri><fr:route>/cs-0010/</fr:route><fr:title text="Crochet de Poisson">Crochet de Poisson</fr:title><fr:taxon>Définition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g]]></fr:tex> deux fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On note <fr:tex display="block"><![CDATA[\{f,g\} = \omega (X_f, X_g) \in  \mathscr {C}^\infty (T^*M).]]></fr:tex></html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:title text="Dans \mathbb {R}^n">Dans <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex></fr:title><fr:taxon>Remarque</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Sur <fr:tex display="inline"><![CDATA[\mathbb {R}^{2n}]]></fr:tex>, on a <fr:tex display="block"><![CDATA[\{ f,g \} = 
    \sum _{i}^n \frac {\partial  f}{\partial  x_i} \frac {\partial  g}{\partial  p_i} - \frac {\partial  f}{\partial  p_i} \frac {\partial  g}{\partial  x_i}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0012/</fr:uri><fr:display-uri>cs-0012</fr:display-uri><fr:route>/cs-0012/</fr:route><fr:title text="L'algèbre de Lie \mathscr {C}^\infty (T^*M)">L'algèbre de Lie <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex></fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f,g,h]]></fr:tex> trois fonctions lisses sur <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex>. On a :</html:p><html:ol><html:li>(linéarité)  <fr:tex display="inline"><![CDATA[\{f, g + \lambda  h\} = \{f,g\} + \lambda \{f,h\} ;]]></fr:tex></html:li>
  <html:li>(antisymétrie) <fr:tex display="inline"><![CDATA[\{f,g\}= -\{g,f\} ;]]></fr:tex></html:li>
  <html:li>(identité de Jacobi) <fr:tex display="inline"><![CDATA[ \{f, \{g,h\} \} + \{g, \{h,f\} \} + \{h, \{f,g\} \} = 0;]]></fr:tex></html:li>
  <html:li>(identité de Leibniz) <fr:tex display="inline"><![CDATA[ \{f, gh\} = \{f,g\}h + \{f,h\}g;]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\partial _t \{f,g\} = \{\partial _t f, g\} + \{f, \partial _t g\}.]]></fr:tex></html:li></html:ol><html:p>En particulier, le crochet de Poisson fait de l'algèbre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> une algèbre de Lie.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Simples vérifications.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0015/</fr:uri><fr:display-uri>cs-0015</fr:display-uri><fr:route>/cs-0015/</fr:route><fr:title text="Morphisme d'algèbres de Lie">Morphisme d'algèbres de Lie</fr:title><fr:taxon>Propriété</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soient <fr:tex display="inline"><![CDATA[f, g\in  \mathscr {C}^\infty (T^*M)]]></fr:tex>. Alors on a <fr:tex display="block"><![CDATA[X_{ \{f, g\} } = [X_f, X_g],]]></fr:tex>
autrement dit <fr:tex display="inline"><![CDATA[f \mapsto  X_f]]></fr:tex> est un morphisme d'algèbres de Lie entre <fr:tex display="inline"><![CDATA[\mathscr {C}^\infty (T^*M)]]></fr:tex> et <fr:tex display="inline"><![CDATA[\mathfrak {X}(T^*M)]]></fr:tex>.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Preuve</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Oui oui...</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0011/</fr:uri><fr:display-uri>cs-0011</fr:display-uri><fr:route>/cs-0011/</fr:route><fr:title text="Équation d'évolution pour un observable quelconque">Équation d'évolution pour un observable quelconque</fr:title><fr:taxon>Théorème</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Soit <fr:tex display="inline"><![CDATA[\gamma ]]></fr:tex> une courbe intégrale de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Soit <fr:tex display="inline"><![CDATA[f\in  \mathscr {C}^\infty (M)]]></fr:tex>. On a l'équation suivante : <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (f \circ  \gamma ) = \{f, H\}.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0013/</fr:uri><fr:display-uri>cs-0013</fr:display-uri><fr:route>/cs-0013/</fr:route><fr:title text="Conservation de l'énergie">Conservation de l'énergie</fr:title><fr:taxon>Corollaire</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>En particulier,  <fr:tex display="block"><![CDATA[\frac {\mathrm {d}}{\mathrm {d} t} (H \circ  \gamma ) = \{H, H\} = 0]]></fr:tex>c'est à dire que <fr:tex display="inline"><![CDATA[H]]></fr:tex> est constante le long du flot de <fr:tex display="inline"><![CDATA[X_H]]></fr:tex>. Autrement dit, il y a conservation de l'énergie mécanique.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-0016/</fr:uri><fr:display-uri>cs-0016</fr:display-uri><fr:route>/cs-0016/</fr:route><fr:title text="L'exemple du pendule sphérique">L'exemple du pendule sphérique</fr:title></fr:frontmatter><fr:mainmatter><html:p>Un pendule sphérique est constitué d'un point de masse <fr:tex display="inline"><![CDATA[m]]></fr:tex> fixé à une tige de longueur 1. La position de la masse est décrite par un point <fr:tex display="inline"><![CDATA[x = (x_1, x_2, x_3) \in  S^2]]></fr:tex> la sphère unité. Sa vitesse est décrite par <fr:tex display="inline"><![CDATA[v \in  T_xS^2]]></fr:tex>, c'est à dire <fr:tex display="inline"><![CDATA[(v_1, v_2, v_3) \in  \mathbb {R}^3]]></fr:tex> tel que <fr:tex display="inline"><![CDATA[v\cdot  x = 0]]></fr:tex>.</html:p><html:p>En tant que sous-variété de <fr:tex display="inline"><![CDATA[\mathbb {R}^3]]></fr:tex>, <fr:tex display="inline"><![CDATA[S^2]]></fr:tex> est munie d'une métrique riemannienne induite. On peut donc dire que le moment de la masse est décrit par <fr:tex display="inline"><![CDATA[p = mv^\flat  \in  T^*S^2]]></fr:tex>.</html:p><html:p>La seule force à laquelle est soumise la masse est la gravité. Cela donne le hamiltonien <fr:tex display="block"><![CDATA[H(x, p) = \frac {1}{2m}\lvert  p^{\sharp }\rvert _g^2 + mg x_3 = \frac {1}{2m}\left (p_{\theta }^2 + \frac {p_\phi ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>en réécrivant le hamiltonien en coordonnées sphériques sur <fr:tex display="inline"><![CDATA[S^2 \setminus  \{S, N\} \cong  ] 0, \pi   [ \times  ] 0, 2\pi   []]></fr:tex>.</html:p><html:p>Les équations de Hamilton sont donc <fr:tex display="block"><![CDATA[\begin {align*}
    \dot \theta  = \frac {p_\theta }{m} \qquad  \dot \phi  = \frac {p_\phi }{m\sin ^2 \theta } \\
    \dot {p}_\theta  = \frac {p_\phi  ^2 \cos  \theta }{m\sin ^3 \theta } + mg \sin  \theta  \qquad  \dot {p}_\phi  = 0
    \end {align*}]]></fr:tex></html:p><html:p>De ces équations, un physicien peut tirer des équations du second ordre en <fr:tex display="inline"><![CDATA[\theta ]]></fr:tex> et <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. On remarque aussi qu'une quantité est conservée : <fr:tex display="block"><![CDATA[p_\phi  = m \sin ^2 \theta  \dot {\phi } = (x \times  mv)_3.]]></fr:tex>
    Il s'agit du moment angulaire autour de l'axe vertical. Il est conservé car le système est invariant par rotation autour de l'axe vertical. C'est une illustration du principe de Noether : à une symétrie correspond une quantité conservée. Appelons-la :<fr:tex display="block"><![CDATA[\begin {align*}J : T^*S^2 &\to  \mathbb {R} \\
    (x,p) &\mapsto  (x \times  mv)_3\end {align*}]]></fr:tex>
    <fr:tex display="inline"><![CDATA[J]]></fr:tex> a une valeur singulière en <fr:tex display="inline"><![CDATA[\mu  = 0]]></fr:tex> venant des singularités aux pôles. Pour <fr:tex display="inline"><![CDATA[\mu  \neq  0]]></fr:tex>, <fr:tex display="inline"><![CDATA[J^{-1}(\mu )]]></fr:tex> est une sous-variété de codimension 1 de <fr:tex display="inline"><![CDATA[T^*S^2]]></fr:tex> qui est invariante par le flot. En coordonnées sphériques, il s'agit simplement de <fr:tex display="inline"><![CDATA[ \{(\theta , \phi , p_\theta , p_\phi  = \mu )\} \cong  ] 0, \pi   [ \times  S^1 \times  \mathbb {R}]]></fr:tex>
    Sur cette sous-variété, la symétrie circulaire donne une action propre et libre de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex>, par translation sur la deuxième coordonnée. On considère l'espace de phase réduit <fr:tex display="block"><![CDATA[M_\mu  := J^{-1}(\mu )/S^1 \cong  ] 0, \pi   [ \times  \mathbb {R}]]></fr:tex>
    qui est encore une variété lisse, de dimension 2 cette fois. C'est l'espace des phases où on a identifié deux états qui ne diffèrent que d'une rotation axiale. Résumons la situation :
    
 
  
  <html:figure><fr:resource hash="08e4848a9957b216e9ca2170ca000550"><fr:resource-content><html:img src="/08e4848a9957b216e9ca2170ca000550.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
\begin {tikzcd}
J^{-1}(\mu ) \arrow [r, "\iota ", hook] \arrow [d, "\pi ", two heads] & T^*S^2 \\
J^{-1}(\mu )/S^1                                                  &       
\end {tikzcd}
    ]]></fr:resource-source></fr:resource></html:figure>
 

    On cherche à obtenir une forme symplectique induite sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex>, c'est à dire une 2-forme <fr:tex display="inline"><![CDATA[\omega _{\text {red}}]]></fr:tex> fermée non dégénérée telle que <fr:tex display="inline"><![CDATA[\pi ^*\omega _{\text {red}} = \iota ^*\omega ]]></fr:tex>. Ici, on voit que <fr:tex display="inline"><![CDATA[\mathrm {d}\theta  \wedge  \mathrm {d} p_\theta ]]></fr:tex> convient.
</html:p><html:p>Cela suffit pour définir le crochet de Poisson et les champs hamiltoniens comme auparavant! Ici, comme le hamiltonien est invariant sous l'action de <fr:tex display="inline"><![CDATA[S^1]]></fr:tex> (en clair, ne dépend pas de <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>), il induit sur <fr:tex display="inline"><![CDATA[M_\mu ]]></fr:tex> le hamiltonien <fr:tex display="block"><![CDATA[H_\mu (\theta , p_\theta ) = \frac {1}{2m}\left (p_{\theta }^2 + \frac {\mu ^2}{\sin ^2 \theta }\right ) + mg \cos  \theta ]]></fr:tex>
et les équations d'Hamilton associées à <fr:tex display="inline"><![CDATA[H_\mu ]]></fr:tex> décrivent la dynamique sur l'espace de phases réduit. (Dans ce cas très spécial, on retrouve simplement les équations déjà connues.)</html:p><html:p>On a ainsi exploité la symétrie pour se ramener d'un système en deux (quatre) dimensions à un système à une (deux) dimensions. C'est la réduction symplectique, qu'on rencontrera en toute généralité plus tard. De plus, la réduction symplectique d'un espace de phases complet <fr:tex display="inline"><![CDATA[T^*M]]></fr:tex> peut donner une variété qui n'est plus naturellement un espace cotangent, mais qui est quand même muni d'une 2-forme fermée non dégénérée induite par la forme symplectique canonique : c'est une variété symplectique !</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/cs/" title="Constance" uri="https://c-sarrazin.github.io/cs/" display-uri="cs" type="local">Constance</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:uri>https://c-sarrazin.github.io/cs-000K/</fr:uri><fr:display-uri>cs-000K</fr:display-uri><fr:route>/cs-000K/</fr:route><fr:title text="Variétés symplectiques">Variétés symplectiques</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
